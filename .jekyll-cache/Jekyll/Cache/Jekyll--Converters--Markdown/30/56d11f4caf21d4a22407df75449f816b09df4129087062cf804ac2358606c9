I"‘~<h1 id="configuration">Configuration</h1>

<p>Tendermint Core can be configured via a TOML file in
<code class="language-plaintext highlighter-rouge">$TMHOME/config/config.toml</code>. Some of these parameters can be overridden by
command-line flags. For most users, the options in the <code class="language-plaintext highlighter-rouge">##### main base configuration options #####</code> are intended to be modified while config options
further below are intended for advance power users.</p>

<h2 id="options">Options</h2>

<p>The default configuration file create by <code class="language-plaintext highlighter-rouge">tendermint init</code> has all
the parameters set with their default values. It will look something
like the file below, however, double check by inspecting the
<code class="language-plaintext highlighter-rouge">config.toml</code> created with your version of <code class="language-plaintext highlighter-rouge">tendermint</code> installed:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This is a TOML config file.</span>
<span class="c"># For more information, see https://github.com/toml-lang/toml</span>

<span class="c"># NOTE: Any path below can be absolute (e.g. "/var/myawesomeapp/data") or</span>
<span class="c"># relative to the home directory (e.g. "data"). The home directory is</span>
<span class="c"># "$HOME/.tendermint" by default, but could be changed via $TMHOME env variable</span>
<span class="c"># or --home cmd flag.</span>

<span class="c">#######################################################################</span>
<span class="c">###                   Main Base Config Options                      ###</span>
<span class="c">#######################################################################</span>

<span class="c"># TCP or UNIX socket address of the ABCI application,</span>
<span class="c"># or the name of an ABCI application compiled in with the Tendermint binary</span>
<span class="py">proxy_app</span> <span class="p">=</span> <span class="s">"tcp://127.0.0.1:26658"</span>

<span class="c"># A custom human readable name for this node</span>
<span class="py">moniker</span> <span class="p">=</span> <span class="s">"anonymous"</span>

<span class="c"># If this node is many blocks behind the tip of the chain, BlockSync</span>
<span class="c"># allows them to catchup quickly by downloading blocks in parallel</span>
<span class="c"># and verifying their commits</span>
<span class="py">block_sync</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c"># Database backend: goleveldb | cleveldb | boltdb | rocksdb | badgerdb</span>
<span class="c"># * goleveldb (github.com/syndtr/goleveldb - most popular implementation)</span>
<span class="c">#   - pure go</span>
<span class="c">#   - stable</span>
<span class="c"># * cleveldb (uses levigo wrapper)</span>
<span class="c">#   - fast</span>
<span class="c">#   - requires gcc</span>
<span class="c">#   - use cleveldb build tag (go build -tags cleveldb)</span>
<span class="c"># * boltdb (uses etcd's fork of bolt - github.com/etcd-io/bbolt)</span>
<span class="c">#   - EXPERIMENTAL</span>
<span class="c">#   - may be faster is some use-cases (random reads - indexer)</span>
<span class="c">#   - use boltdb build tag (go build -tags boltdb)</span>
<span class="c"># * rocksdb (uses github.com/tecbot/gorocksdb)</span>
<span class="c">#   - EXPERIMENTAL</span>
<span class="c">#   - requires gcc</span>
<span class="c">#   - use rocksdb build tag (go build -tags rocksdb)</span>
<span class="c"># * badgerdb (uses github.com/dgraph-io/badger)</span>
<span class="c">#   - EXPERIMENTAL</span>
<span class="c">#   - use badgerdb build tag (go build -tags badgerdb)</span>
<span class="py">db_backend</span> <span class="p">=</span> <span class="s">"goleveldb"</span>

<span class="c"># Database directory</span>
<span class="py">db_dir</span> <span class="p">=</span> <span class="s">"data"</span>

<span class="c"># Output level for logging, including package level options</span>
<span class="py">log_level</span> <span class="p">=</span> <span class="s">"main:info,state:info,statesync:info,*:error"</span>

<span class="c"># Output format: 'plain' (colored text) or 'json'</span>
<span class="py">log_format</span> <span class="p">=</span> <span class="s">"plain"</span>

<span class="c">##### additional base config options #####</span>

<span class="c"># Path to the JSON file containing the initial validator set and other meta data</span>
<span class="py">genesis_file</span> <span class="p">=</span> <span class="s">"config/genesis.json"</span>

<span class="c"># Path to the JSON file containing the private key to use as a validator in the consensus protocol</span>
<span class="py">priv_validator_key_file</span> <span class="p">=</span> <span class="s">"config/priv_validator_key.json"</span>

<span class="c"># Path to the JSON file containing the last sign state of a validator</span>
<span class="py">priv_validator_state_file</span> <span class="p">=</span> <span class="s">"data/priv_validator_state.json"</span>

<span class="c"># TCP or UNIX socket address for Tendermint to listen on for</span>
<span class="c"># connections from an external PrivValidator process</span>
<span class="py">priv_validator_laddr</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Path to the JSON file containing the private key to use for node authentication in the p2p protocol</span>
<span class="py">node_key_file</span> <span class="p">=</span> <span class="s">"config/node_key.json"</span>

<span class="c"># Mechanism to connect to the ABCI application: socket | grpc</span>
<span class="py">abci</span> <span class="p">=</span> <span class="s">"socket"</span>

<span class="c"># If true, query the ABCI app on connecting to a new peer</span>
<span class="c"># so the app can decide if we should keep the connection or not</span>
<span class="py">filter_peers</span> <span class="p">=</span> <span class="kc">false</span>


<span class="c">#######################################################################</span>
<span class="c">###                 Advanced Configuration Options                  ###</span>
<span class="c">#######################################################################</span>

<span class="c">#######################################################</span>
<span class="c">###       RPC Server Configuration Options          ###</span>
<span class="c">#######################################################</span>
<span class="nn">[rpc]</span>

<span class="c"># TCP or UNIX socket address for the RPC server to listen on</span>
<span class="py">laddr</span> <span class="p">=</span> <span class="s">"tcp://127.0.0.1:26657"</span>

<span class="c"># A list of origins a cross-domain request can be executed from</span>
<span class="c"># Default value '[]' disables cors support</span>
<span class="c"># Use '["*"]' to allow any origin</span>
<span class="py">cors_allowed_origins</span> <span class="p">=</span> <span class="p">[]</span>

<span class="c"># A list of methods the client is allowed to use with cross-domain requests</span>
<span class="py">cors_allowed_methods</span> <span class="p">=</span> <span class="p">[</span><span class="s">"HEAD"</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">,</span> <span class="s">"POST"</span><span class="p">,</span> <span class="p">]</span>

<span class="c"># A list of non simple headers the client is allowed to use with cross-domain requests</span>
<span class="py">cors_allowed_headers</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Origin"</span><span class="p">,</span> <span class="s">"Accept"</span><span class="p">,</span> <span class="s">"Content-Type"</span><span class="p">,</span> <span class="s">"X-Requested-With"</span><span class="p">,</span> <span class="s">"X-Server-Time"</span><span class="p">,</span> <span class="p">]</span>

<span class="c"># TCP or UNIX socket address for the gRPC server to listen on</span>
<span class="c"># NOTE: This server only supports /broadcast_tx_commit</span>
<span class="py">grpc_laddr</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Maximum number of simultaneous connections.</span>
<span class="c"># Does not include RPC (HTTP&amp;WebSocket) connections. See max_open_connections</span>
<span class="c"># If you want to accept a larger number than the default, make sure</span>
<span class="c"># you increase your OS limits.</span>
<span class="c"># 0 - unlimited.</span>
<span class="c"># Should be &lt; {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}</span>
<span class="c"># 1024 - 40 - 10 - 50 = 924 = ~900</span>
<span class="py">grpc_max_open_connections</span> <span class="p">=</span> <span class="mi">900</span>

<span class="c"># Activate unsafe RPC commands like /dial_seeds and /unsafe_flush_mempool</span>
<span class="py">unsafe</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Maximum number of simultaneous connections (including WebSocket).</span>
<span class="c"># Does not include gRPC connections. See grpc_max_open_connections</span>
<span class="c"># If you want to accept a larger number than the default, make sure</span>
<span class="c"># you increase your OS limits.</span>
<span class="c"># 0 - unlimited.</span>
<span class="c"># Should be &lt; {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}</span>
<span class="c"># 1024 - 40 - 10 - 50 = 924 = ~900</span>
<span class="py">max_open_connections</span> <span class="p">=</span> <span class="mi">900</span>

<span class="c"># Maximum number of unique clientIDs that can /subscribe</span>
<span class="c"># If you're using /broadcast_tx_commit, set to the estimated maximum number</span>
<span class="c"># of broadcast_tx_commit calls per block.</span>
<span class="py">max_subscription_clients</span> <span class="p">=</span> <span class="mi">100</span>

<span class="c"># Maximum number of unique queries a given client can /subscribe to</span>
<span class="c"># If you're using GRPC (or Local RPC client) and /broadcast_tx_commit, set to</span>
<span class="c"># the estimated # maximum number of broadcast_tx_commit calls per block.</span>
<span class="py">max_subscriptions_per_client</span> <span class="p">=</span> <span class="mi">5</span>

<span class="c"># How long to wait for a tx to be committed during /broadcast_tx_commit.</span>
<span class="c"># WARNING: Using a value larger than 10s will result in increasing the</span>
<span class="c"># global HTTP write timeout, which applies to all connections and endpoints.</span>
<span class="c"># See https://github.com/tendermint/tendermint/issues/3435</span>
<span class="py">timeout_broadcast_tx_commit</span> <span class="p">=</span> <span class="s">"10s"</span>

<span class="c"># Maximum size of request body, in bytes</span>
<span class="py">max_body_bytes</span> <span class="p">=</span> <span class="mi">1000000</span>

<span class="c"># Maximum size of request header, in bytes</span>
<span class="py">max_header_bytes</span> <span class="p">=</span> <span class="mi">1048576</span>

<span class="c"># The path to a file containing certificate that is used to create the HTTPS server.</span>
<span class="c"># Migth be either absolute path or path related to tendermint's config directory.</span>
<span class="c"># If the certificate is signed by a certificate authority,</span>
<span class="c"># the certFile should be the concatenation of the server's certificate, any intermediates,</span>
<span class="c"># and the CA's certificate.</span>
<span class="c"># NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server.</span>
<span class="c"># Otherwise, HTTP server is run.</span>
<span class="py">tls_cert_file</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># The path to a file containing matching private key that is used to create the HTTPS server.</span>
<span class="c"># Migth be either absolute path or path related to tendermint's config directory.</span>
<span class="c"># NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server.</span>
<span class="c"># Otherwise, HTTP server is run.</span>
<span class="py">tls_key_file</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># pprof listen address (https://golang.org/pkg/net/http/pprof)</span>
<span class="py">pprof_laddr</span> <span class="p">=</span> <span class="s">""</span>

<span class="c">#######################################################</span>
<span class="c">###           P2P Configuration Options             ###</span>
<span class="c">#######################################################</span>
<span class="nn">[p2p]</span>

<span class="c"># Address to listen for incoming connections</span>
<span class="py">laddr</span> <span class="p">=</span> <span class="s">"tcp://0.0.0.0:26656"</span>

<span class="c"># Address to advertise to peers for them to dial</span>
<span class="c"># If empty, will use the same port as the laddr,</span>
<span class="c"># and will introspect on the listener or use UPnP</span>
<span class="c"># to figure out the address.</span>
<span class="py">external_address</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Comma separated list of seed nodes to connect to</span>
<span class="py">seeds</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Comma separated list of nodes to keep persistent connections to</span>
<span class="py">persistent_peers</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># UPNP port forwarding</span>
<span class="py">upnp</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Path to address book</span>
<span class="py">addr_book_file</span> <span class="p">=</span> <span class="s">"config/addrbook.json"</span>

<span class="c"># Set true for strict address routability rules</span>
<span class="c"># Set false for private or local networks</span>
<span class="py">addr_book_strict</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c"># Maximum number of inbound peers</span>
<span class="py">max_num_inbound_peers</span> <span class="p">=</span> <span class="mi">40</span>

<span class="c"># Maximum number of outbound peers to connect to, excluding persistent peers</span>
<span class="py">max_num_outbound_peers</span> <span class="p">=</span> <span class="mi">10</span>

<span class="c"># List of node IDs, to which a connection will be (re)established ignoring any existing limits</span>
<span class="py">unconditional_peer_ids</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Maximum pause when redialing a persistent peer (if zero, exponential backoff is used)</span>
<span class="py">persistent_peers_max_dial_period</span> <span class="p">=</span> <span class="s">"0s"</span>

<span class="c"># Time to wait before flushing messages out on the connection</span>
<span class="py">flush_throttle_timeout</span> <span class="p">=</span> <span class="s">"100ms"</span>

<span class="c"># Maximum size of a message packet payload, in bytes</span>
<span class="py">max_packet_msg_payload_size</span> <span class="p">=</span> <span class="mi">1024</span>

<span class="c"># Rate at which packets can be sent, in bytes/second</span>
<span class="py">send_rate</span> <span class="p">=</span> <span class="mi">5120000</span>

<span class="c"># Rate at which packets can be received, in bytes/second</span>
<span class="py">recv_rate</span> <span class="p">=</span> <span class="mi">5120000</span>

<span class="c"># Set true to enable the peer-exchange reactor</span>
<span class="py">pex</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c"># Seed mode, in which node constantly crawls the network and looks for</span>
<span class="c"># peers. If another node asks it for addresses, it responds and disconnects.</span>
<span class="c">#</span>
<span class="c"># Does not work if the peer-exchange reactor is disabled.</span>
<span class="py">seed_mode</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Comma separated list of peer IDs to keep private (will not be gossiped to other peers)</span>
<span class="py">private_peer_ids</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Toggle to disable guard against peers connecting from the same ip.</span>
<span class="py">allow_duplicate_ip</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Peer connection configuration.</span>
<span class="py">handshake_timeout</span> <span class="p">=</span> <span class="s">"20s"</span>
<span class="py">dial_timeout</span> <span class="p">=</span> <span class="s">"3s"</span>

<span class="c">#######################################################</span>
<span class="c">###          Mempool Configurattion Option          ###</span>
<span class="c">#######################################################</span>
<span class="nn">[mempool]</span>

<span class="py">recheck</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">broadcast</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">wal_dir</span> <span class="p">=</span> <span class="s">""</span>

<span class="c"># Maximum number of transactions in the mempool</span>
<span class="py">size</span> <span class="p">=</span> <span class="mi">5000</span>

<span class="c"># Limit the total size of all txs in the mempool.</span>
<span class="c"># This only accounts for raw transactions (e.g. given 1MB transactions and</span>
<span class="c"># max_txs_bytes=5MB, mempool will only accept 5 transactions).</span>
<span class="py">max_txs_bytes</span> <span class="p">=</span> <span class="mi">1073741824</span>

<span class="c"># Size of the cache (used to filter transactions we saw earlier) in transactions</span>
<span class="py">cache_size</span> <span class="p">=</span> <span class="mi">10000</span>

<span class="c"># Do not remove invalid transactions from the cache (default: false)</span>
<span class="c"># Set to true if it's not possible for any invalid transaction to become valid</span>
<span class="c"># again in the future.</span>
<span class="py">keep-invalid-txs-in-cache</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Maximum size of a single transaction.</span>
<span class="c"># NOTE: the max size of a tx transmitted over the network is {max_tx_bytes}.</span>
<span class="py">max_tx_bytes</span> <span class="p">=</span> <span class="mi">1048576</span>

<span class="c"># Maximum size of a batch of transactions to send to a peer</span>
<span class="c"># Including space needed by encoding (one varint per transaction).</span>
<span class="c"># XXX: Unused due to https://github.com/tendermint/tendermint/issues/5796</span>
<span class="py">max_batch_bytes</span> <span class="p">=</span> <span class="mi">10485760</span>

<span class="c">#######################################################</span>
<span class="c">###         State Sync Configuration Options        ###</span>
<span class="c">#######################################################</span>
<span class="nn">[statesync]</span>
<span class="c"># State sync rapidly bootstraps a new node by discovering, fetching, and restoring a state machine</span>
<span class="c"># snapshot from peers instead of fetching and replaying historical blocks. Requires some peers in</span>
<span class="c"># the network to take and serve state machine snapshots. State sync is not attempted if the node</span>
<span class="c"># has any local state (LastBlockHeight &gt; 0). The node will have a truncated block history,</span>
<span class="c"># starting from the height of the snapshot.</span>
<span class="py">enable</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># RPC servers (comma-separated) for light client verification of the synced state machine and</span>
<span class="c"># retrieval of state data for node bootstrapping. Also needs a trusted height and corresponding</span>
<span class="c"># header hash obtained from a trusted source, and a period during which validators can be trusted.</span>
<span class="c">#</span>
<span class="c"># For Cosmos SDK-based chains, trust_period should usually be about 2/3 of the unbonding time (~2</span>
<span class="c"># weeks) during which they can be financially punished (slashed) for misbehavior.</span>
<span class="py">rpc_servers</span> <span class="p">=</span> <span class="s">""</span>
<span class="py">trust_height</span> <span class="p">=</span> <span class="mi">0</span>
<span class="py">trust_hash</span> <span class="p">=</span> <span class="s">""</span>
<span class="py">trust_period</span> <span class="p">=</span> <span class="s">"0s"</span>

<span class="c"># Temporary directory for state sync snapshot chunks, defaults to the OS tempdir (typically /tmp).</span>
<span class="c"># Will create a new, randomly named directory within, and remove it when done.</span>
<span class="py">temp_dir</span> <span class="p">=</span> <span class="s">""</span>

<span class="c">#######################################################</span>
<span class="c">###       Block Sync Configuration Options          ###</span>
<span class="c">#######################################################</span>
<span class="nn">[blocksync]</span>

<span class="c"># Block Sync version to use:</span>
<span class="c"># </span>
<span class="c"># In v0.37, v1 and v2 of the block sync protocols were deprecated.</span>
<span class="c"># Please use v0 instead.</span>
<span class="c">#</span>
<span class="c">#   1) "v0" - the default block sync implementation</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"v0"</span>

<span class="c">#######################################################</span>
<span class="c">###         Consensus Configuration Options         ###</span>
<span class="c">#######################################################</span>
<span class="nn">[consensus]</span>

<span class="py">wal_file</span> <span class="p">=</span> <span class="s">"data/cs.wal/wal"</span>

<span class="c"># How long we wait for a proposal block before prevoting nil</span>
<span class="py">timeout_propose</span> <span class="p">=</span> <span class="s">"3s"</span>
<span class="c"># How much timeout_propose increases with each round</span>
<span class="py">timeout_propose_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="c"># How long we wait after receiving +2/3 prevotes for ‚Äúanything‚Äù (ie. not a single block or nil)</span>
<span class="py">timeout_prevote</span> <span class="p">=</span> <span class="s">"1s"</span>
<span class="c"># How much the timeout_prevote increases with each round</span>
<span class="py">timeout_prevote_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="c"># How long we wait after receiving +2/3 precommits for ‚Äúanything‚Äù (ie. not a single block or nil)</span>
<span class="py">timeout_precommit</span> <span class="p">=</span> <span class="s">"1s"</span>
<span class="c"># How much the timeout_precommit increases with each round</span>
<span class="py">timeout_precommit_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="c"># How long we wait after committing a block, before starting on the new</span>
<span class="c"># height (this gives us a chance to receive some more precommits, even</span>
<span class="c"># though we already have +2/3).</span>
<span class="py">timeout_commit</span> <span class="p">=</span> <span class="s">"1s"</span>

<span class="c"># How many blocks to look back to check existence of the node's consensus votes before joining consensus</span>
<span class="c"># When non-zero, the node will panic upon restart</span>
<span class="c"># if the same consensus key was used to sign {double_sign_check_height} last blocks.</span>
<span class="c"># So, validators should stop the state machine, wait for some blocks, and then restart the state machine to avoid panic.</span>
<span class="py">double_sign_check_height</span> <span class="p">=</span> <span class="mi">0</span>

<span class="c"># Make progress as soon as we have all the precommits (as if TimeoutCommit = 0)</span>
<span class="py">skip_timeout_commit</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># EmptyBlocks mode and possible interval between empty blocks</span>
<span class="py">create_empty_blocks</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">create_empty_blocks_interval</span> <span class="p">=</span> <span class="s">"0s"</span>

<span class="c"># Reactor sleep duration parameters</span>
<span class="py">peer_gossip_sleep_duration</span> <span class="p">=</span> <span class="s">"100ms"</span>
<span class="py">peer_query_maj23_sleep_duration</span> <span class="p">=</span> <span class="s">"2s"</span>

<span class="c">#######################################################</span>
<span class="c">###   Transaction Indexer Configuration Options     ###</span>
<span class="c">#######################################################</span>
<span class="nn">[tx_index]</span>

<span class="c"># What indexer to use for transactions</span>
<span class="c">#</span>
<span class="c"># The application will set which txs to index. In some cases a node operator will be able</span>
<span class="c"># to decide which txs to index based on configuration set in the application.</span>
<span class="c">#</span>
<span class="c"># Options:</span>
<span class="c">#   1) "null"</span>
<span class="c">#   2) "kv" (default) - the simplest possible indexer, backed by key-value storage (defaults to levelDB; see DBBackend).</span>
<span class="c"># 		- When "kv" is chosen "tx.height" and "tx.hash" will always be indexed.</span>
<span class="py">indexer</span> <span class="p">=</span> <span class="s">"kv"</span>

<span class="c">#######################################################</span>
<span class="c">###       Instrumentation Configuration Options     ###</span>
<span class="c">#######################################################</span>
<span class="nn">[instrumentation]</span>

<span class="c"># When true, Prometheus metrics are served under /metrics on</span>
<span class="c"># PrometheusListenAddr.</span>
<span class="c"># Check out the documentation for the list of available metrics.</span>
<span class="py">prometheus</span> <span class="p">=</span> <span class="kc">false</span>

<span class="c"># Address to listen for Prometheus collector(s) connections</span>
<span class="py">prometheus_listen_addr</span> <span class="p">=</span> <span class="s">":26660"</span>

<span class="c"># Maximum number of simultaneous connections.</span>
<span class="c"># If you want to accept a larger number than the default, make sure</span>
<span class="c"># you increase your OS limits.</span>
<span class="c"># 0 - unlimited.</span>
<span class="py">max_open_connections</span> <span class="p">=</span> <span class="mi">3</span>

<span class="c"># Instrumentation namespace</span>
<span class="py">namespace</span> <span class="p">=</span> <span class="s">"tendermint"</span>

</code></pre></div></div>

<h2 id="empty-blocks-vs-no-empty-blocks">Empty blocks VS no empty blocks</h2>

<h3 id="create_empty_blocks--true">create_empty_blocks = true</h3>

<p>If <code class="language-plaintext highlighter-rouge">create_empty_blocks</code> is set to <code class="language-plaintext highlighter-rouge">true</code> in your config, blocks will be
created ~ every second (with default consensus parameters). You can regulate
the delay between blocks by changing the <code class="language-plaintext highlighter-rouge">timeout_commit</code>. E.g. <code class="language-plaintext highlighter-rouge">timeout_commit = "10s"</code> should result in ~ 10 second blocks.</p>

<h3 id="create_empty_blocks--false">create_empty_blocks = false</h3>

<p>In this setting, blocks are created when transactions received.</p>

<p>Note after the block H, Tendermint creates something we call a ‚Äúproof block‚Äù
(only if the application hash changed) H+1. The reason for this is to support
proofs. If you have a transaction in block H that changes the state to X, the
new application hash will only be included in block H+1. If after your
transaction is committed, you want to get a light-client proof for the new state
(X), you need the new block to be committed in order to do that because the new
block has the new application hash for the state X. That‚Äôs why we make a new
(empty) block if the application hash changes. Otherwise, you won‚Äôt be able to
make a proof for the new state.</p>

<p>Plus, if you set <code class="language-plaintext highlighter-rouge">create_empty_blocks_interval</code> to something other than the
default (<code class="language-plaintext highlighter-rouge">0</code>), Tendermint will be creating empty blocks even in the absence of
transactions every <code class="language-plaintext highlighter-rouge">create_empty_blocks_interval</code>. For instance, with
<code class="language-plaintext highlighter-rouge">create_empty_blocks = false</code> and <code class="language-plaintext highlighter-rouge">create_empty_blocks_interval = "30s"</code>,
Tendermint will only create blocks if there are transactions, or after waiting
30 seconds without receiving any transactions.</p>

<h2 id="consensus-timeouts-explained">Consensus timeouts explained</h2>

<p>There‚Äôs a variety of information about timeouts in <a href="./running-in-production.md">Running in
production</a></p>

<p>You can also find more detailed technical explanation in the spec: <a href="https://arxiv.org/abs/1807.04938">The latest
gossip on BFT consensus</a>.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[consensus]</span>
<span class="err">...</span>

<span class="py">timeout_propose</span> <span class="p">=</span> <span class="s">"3s"</span>
<span class="py">timeout_propose_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="py">timeout_prevote</span> <span class="p">=</span> <span class="s">"1s"</span>
<span class="py">timeout_prevote_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="py">timeout_precommit</span> <span class="p">=</span> <span class="s">"1s"</span>
<span class="py">timeout_precommit_delta</span> <span class="p">=</span> <span class="s">"500ms"</span>
<span class="py">timeout_commit</span> <span class="p">=</span> <span class="s">"1s"</span>
</code></pre></div></div>

<p>Note that in a successful round, the only timeout that we absolutely wait no
matter what is <code class="language-plaintext highlighter-rouge">timeout_commit</code>.</p>

<p>Here‚Äôs a brief summary of the timeouts:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">timeout_propose</code> = how long we wait for a proposal block before prevoting
nil</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_propose_delta</code> = how much timeout_propose increases with each round</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_prevote</code> = how long we wait after receiving +2/3 prevotes for
anything (ie. not a single block or nil)</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_prevote_delta</code> = how much the timeout_prevote increases with each
round</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_precommit</code> = how long we wait after receiving +2/3 precommits for
anything (ie. not a single block or nil)</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_precommit_delta</code> = how much the timeout_precommit increases with
each round</li>
  <li><code class="language-plaintext highlighter-rouge">timeout_commit</code> = how long we wait after committing a block, before starting
on the new height (this gives us a chance to receive some more precommits,
even though we already have +2/3)</li>
</ul>
:ET