I"ê$<h1 id="state-sync">State Sync</h1>

<h2 id="channels">Channels</h2>

<p>State sync has four distinct channels. The channel identifiers are listed below.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SnapshotChannel</td>
      <td>96</td>
    </tr>
    <tr>
      <td>ChunkChannel</td>
      <td>97</td>
    </tr>
    <tr>
      <td>LightBlockChannel</td>
      <td>98</td>
    </tr>
    <tr>
      <td>ParamsChannel</td>
      <td>99</td>
    </tr>
  </tbody>
</table>

<h2 id="message-types">Message Types</h2>

<h3 id="snapshotrequest">SnapshotRequest</h3>

<p>When a new node begin state syncing, it will ask all peers it encounters if it has any
available snapshots:</p>

<p>| Name     | Type   | Description | Field Number |
|â€”â€”â€”-|â€”â€”â€“|â€”â€”â€”â€”-|â€”â€”â€”â€”â€“|</p>

<h3 id="snapshotresponse">SnapShotResponse</h3>

<p>The receiver will query the local ABCI application via <code class="language-plaintext highlighter-rouge">ListSnapshots</code>, and send a message
containing snapshot metadata (limited to 4 MB) for each of the 10 most recent snapshots: and stored at the application layer. When a peer is starting it will request snapshots.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height at which the snapshot was taken</td>
      <td>1</td>
    </tr>
    <tr>
      <td>format</td>
      <td>uint32</td>
      <td>Format of the snapshot.</td>
      <td>2</td>
    </tr>
    <tr>
      <td>chunks</td>
      <td>uint32</td>
      <td>How many chunks make up the snapshot</td>
      <td>3</td>
    </tr>
    <tr>
      <td>hash</td>
      <td>bytes</td>
      <td>Arbitrary snapshot hash</td>
      <td>4</td>
    </tr>
    <tr>
      <td>metadata</td>
      <td>bytes</td>
      <td>Arbitrary application data. <strong>May be non-deterministic.</strong></td>
      <td>5</td>
    </tr>
  </tbody>
</table>

<h3 id="chunkrequest">ChunkRequest</h3>

<p>The node running state sync will offer these snapshots to the local ABCI application via
<code class="language-plaintext highlighter-rouge">OfferSnapshot</code> ABCI calls, and keep track of which peers contain which snapshots. Once a snapshot
is accepted, the state syncer will request snapshot chunks from appropriate peers:</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height at which the chunk was created</td>
      <td>1</td>
    </tr>
    <tr>
      <td>format</td>
      <td>uint32</td>
      <td>Format chosen for the chunk.  <strong>May be non-deterministic.</strong></td>
      <td>2</td>
    </tr>
    <tr>
      <td>index</td>
      <td>uint32</td>
      <td>Index of the chunk within the snapshot.</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<h3 id="chunkresponse">ChunkResponse</h3>

<p>The receiver will load the requested chunk from its local application via <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code>,
and respond with it (limited to 16 MB):</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height at which the chunk was created</td>
      <td>1</td>
    </tr>
    <tr>
      <td>format</td>
      <td>uint32</td>
      <td>Format chosen for the chunk.  <strong>May be non-deterministic.</strong></td>
      <td>2</td>
    </tr>
    <tr>
      <td>index</td>
      <td>uint32</td>
      <td>Index of the chunk within the snapshot.</td>
      <td>3</td>
    </tr>
    <tr>
      <td>hash</td>
      <td>bytes</td>
      <td>Arbitrary snapshot hash</td>
      <td>4</td>
    </tr>
    <tr>
      <td>missing</td>
      <td>bool</td>
      <td>Arbitrary application data. <strong>May be non-deterministic.</strong></td>
      <td>5</td>
    </tr>
  </tbody>
</table>

<p>Here, <code class="language-plaintext highlighter-rouge">Missing</code> is used to signify that the chunk was not found on the peer, since an empty
chunk is a valid (although unlikely) response.</p>

<p>The returned chunk is given to the ABCI application via <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> until the snapshot
is restored. If a chunk response is not returned within some time, it will be re-requested,
possibly from a different peer.</p>

<p>The ABCI application is able to request peer bans and chunk refetching as part of the ABCI protocol.</p>

<h3 id="lightblockrequest">LightBlockRequest</h3>

<p>To verify state and to provide state relevant information for consensus, the node will ask peers for
light blocks at specified heights.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height of the light block</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h3 id="lightblockresponse">LightBlockResponse</h3>

<p>The receiver will retrieve and construct the light block from both the block and state stores. The
receiver will verify the data by comparing the hashes and store the header, commit and validator set
if necessary. The light block at the height of the snapshot will be used to verify the <code class="language-plaintext highlighter-rouge">AppHash</code>.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>light_block</td>
      <td><a href="/v0.37/spec/core/data_structures.md#lightblock">LightBlock</a></td>
      <td>Light block at the height requested</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>State sync will use <a href="/v0.37/spec/light-client/verification/README/">light client verification</a> to verify
the light blocks.</p>

<p>If no state sync is in progress (i.e. during normal operation), any unsolicited response messages
are discarded.</p>

<h3 id="paramsrequest">ParamsRequest</h3>

<p>In order to build the state, the state provider will request the params at the height of the snapshot and use the header to verify it.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height of the consensus params</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<h3 id="paramsresponse">ParamsResponse</h3>

<p>A reciever to the request will use the state store to fetch the consensus params at that height and return it to the sender.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>height</td>
      <td>uint64</td>
      <td>Height of the consensus params</td>
      <td>1</td>
    </tr>
    <tr>
      <td>consensus_params</td>
      <td><a href="/v0.37/spec/core/data_structures.md#ConsensusParams">ConsensusParams</a></td>
      <td>Consensus params at the height requested</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<h3 id="message">Message</h3>

<p>Message is a <a href="https://developers.google.com/protocol-buffers/docs/proto#oneof"><code class="language-plaintext highlighter-rouge">oneof</code> protobuf type</a>. The <code class="language-plaintext highlighter-rouge">oneof</code> consists of eight messages.</p>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Field Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>snapshots_request</td>
      <td><a href="#snapshotrequest">SnapshotRequest</a></td>
      <td>Request a recent snapshot from a peer</td>
      <td>1</td>
    </tr>
    <tr>
      <td>snapshots_response</td>
      <td><a href="#snapshotresponse">SnapshotResponse</a></td>
      <td>Respond with the most recent snapshot stored</td>
      <td>2</td>
    </tr>
    <tr>
      <td>chunk_request</td>
      <td><a href="#chunkrequest">ChunkRequest</a></td>
      <td>Request chunks of the snapshot.</td>
      <td>3</td>
    </tr>
    <tr>
      <td>chunk_response</td>
      <td><a href="#chunkresponse">ChunkRequest</a></td>
      <td>Response of chunks used to recreate state.</td>
      <td>4</td>
    </tr>
    <tr>
      <td>light_block_request</td>
      <td><a href="#lightblockrequest">LightBlockRequest</a></td>
      <td>Request a light block.</td>
      <td>5</td>
    </tr>
    <tr>
      <td>light_block_response</td>
      <td><a href="#lightblockresponse">LightBlockResponse</a></td>
      <td>Respond with a light block</td>
      <td>6</td>
    </tr>
    <tr>
      <td>params_request</td>
      <td><a href="#paramsrequest">ParamsRequest</a></td>
      <td>Request the consensus params at a height.</td>
      <td>7</td>
    </tr>
    <tr>
      <td>params_response</td>
      <td><a href="#paramsresponse">ParamsResponse</a></td>
      <td>Respond with the consensus params</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
:ET