I"iU<h1 id="running-in-production">Running in production</h1>

<h2 id="database">Database</h2>

<p>By default, Tendermint uses the <code class="language-plaintext highlighter-rouge">syndtr/goleveldb</code> package for its in-process
key-value database. If you want maximal performance, it may be best to install
the real C-implementation of LevelDB and compile Tendermint to use that using
<code class="language-plaintext highlighter-rouge">make build COMETBFT_BUILD_OPTIONS=cleveldb</code>. See the <a href="../introduction/install.md">install
instructions</a> for details.</p>

<p>Tendermint keeps multiple distinct databases in the <code class="language-plaintext highlighter-rouge">$TMROOT/data</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">blockstore.db</code>: Keeps the entire blockchain - stores blocks,
block commits, and block meta data, each indexed by height. Used to sync new
peers.</li>
  <li><code class="language-plaintext highlighter-rouge">evidence.db</code>: Stores all verified evidence of misbehavior.</li>
  <li><code class="language-plaintext highlighter-rouge">state.db</code>: Stores the current blockchain state (ie. height, validators,
consensus params). Only grows if consensus params or validators change. Also
used to temporarily store intermediate results during block processing.</li>
  <li><code class="language-plaintext highlighter-rouge">tx_index.db</code>: Indexes txs (and their results) by tx hash and by DeliverTx result events.</li>
</ul>

<p>By default, Tendermint will only index txs by their hash and height, not by their DeliverTx
result events. See <a href="/v0.34/app-dev/indexing-transactions/">indexing transactions</a> for
details.</p>

<p>Applications can expose block pruning strategies to the node operator. Please read the documentation of your application
to find out more details.</p>

<p>Applications can use <a href="/v0.34/tendermint-core/state-sync/">state sync</a> to help nodes bootstrap quickly.</p>

<h2 id="logging">Logging</h2>

<p>Default logging level (<code class="language-plaintext highlighter-rouge">log_level = "main:info,state:info,statesync:info,*:error"</code>) should suffice for
normal operation mode. Read <a href="https://blog.cosmos.network/one-of-the-exciting-new-features-in-0-10-0-release-is-smart-log-level-flag-e2506b4ab756">this
post</a>
for details on how to configure <code class="language-plaintext highlighter-rouge">log_level</code> config variable. Some of the
modules can be found <a href="/v0.34/tendermint-core/how-to-read-logs/#list-of-modules">here</a>. If
you’re trying to debug Tendermint or asked to provide logs with debug
logging level, you can do so by running Tendermint with
<code class="language-plaintext highlighter-rouge">--log_level="*:debug"</code>.</p>

<h2 id="write-ahead-logs-wal">Write Ahead Logs (WAL)</h2>

<p>Tendermint uses write ahead logs for the consensus (<code class="language-plaintext highlighter-rouge">cs.wal</code>) and the mempool
(<code class="language-plaintext highlighter-rouge">mempool.wal</code>). Both WALs have a max size of 1GB and are automatically rotated.</p>

<h3 id="consensus-wal">Consensus WAL</h3>

<p>The <code class="language-plaintext highlighter-rouge">consensus.wal</code> is used to ensure we can recover from a crash at any point
in the consensus state machine.
It writes all consensus messages (timeouts, proposals, block part, or vote)
to a single file, flushing to disk before processing messages from its own
validator. Since Tendermint validators are expected to never sign a conflicting vote, the
WAL ensures we can always recover deterministically to the latest state of the consensus without
using the network or re-signing any consensus messages.</p>

<p>If your <code class="language-plaintext highlighter-rouge">consensus.wal</code> is corrupted, see <a href="#wal-corruption">below</a>.</p>

<h3 id="mempool-wal">Mempool WAL</h3>

<p>The <code class="language-plaintext highlighter-rouge">mempool.wal</code> logs all incoming txs before running CheckTx, but is
otherwise not used in any programmatic way. It’s just a kind of manual
safe guard. Note the mempool provides no durability guarantees - a tx sent to one or many nodes
may never make it into the blockchain if those nodes crash before being able to
propose it. Clients must monitor their txs by subscribing over websockets,
polling for them, or using <code class="language-plaintext highlighter-rouge">/broadcast_tx_commit</code>. In the worst case, txs can be
resent from the mempool WAL manually.</p>

<p>For the above reasons, the <code class="language-plaintext highlighter-rouge">mempool.wal</code> is disabled by default. To enable, set
<code class="language-plaintext highlighter-rouge">mempool.wal_dir</code> to where you want the WAL to be located (e.g.
<code class="language-plaintext highlighter-rouge">data/mempool.wal</code>).</p>

<h2 id="dos-exposure-and-mitigation">DOS Exposure and Mitigation</h2>

<p>Validators are supposed to setup <a href="./validators.md">Sentry Node
Architecture</a>
to prevent Denial-of-service attacks.</p>

<h3 id="p2p">P2P</h3>

<p>The core of the Tendermint peer-to-peer system is <code class="language-plaintext highlighter-rouge">MConnection</code>. Each
connection has <code class="language-plaintext highlighter-rouge">MaxPacketMsgPayloadSize</code>, which is the maximum packet
size and bounded send &amp; receive queues. One can impose restrictions on
send &amp; receive rate per connection (<code class="language-plaintext highlighter-rouge">SendRate</code>, <code class="language-plaintext highlighter-rouge">RecvRate</code>).</p>

<p>The number of open P2P connections can become quite large, and hit the operating system’s open
file limit (since TCP connections are considered files on UNIX-based systems). Nodes should be
given a sizable open file limit, e.g. 8192, via <code class="language-plaintext highlighter-rouge">ulimit -n 8192</code> or other deployment-specific
mechanisms.</p>

<h3 id="rpc">RPC</h3>

<p>Endpoints returning multiple entries are limited by default to return 30
elements (100 max). See the <a href="https://docs.tendermint.com/main/rpc/">RPC Documentation</a>
for more information.</p>

<p>Rate-limiting and authentication are another key aspects to help protect
against DOS attacks. Validators are supposed to use external tools like
<a href="https://www.nginx.com/blog/rate-limiting-nginx/">NGINX</a> or
<a href="https://doc.traefik.io/traefik/middlewares/http/ratelimit/">traefik</a>
to achieve the same things.</p>

<h2 id="debugging-tendermint">Debugging Tendermint</h2>

<p>If you ever have to debug Tendermint, the first thing you should probably do is
check out the logs. See <a href="/v0.34/tendermint-core/how-to-read-logs/">How to read logs</a>, where we
explain what certain log statements mean.</p>

<p>If, after skimming through the logs, things are not clear still, the next thing
to try is querying the <code class="language-plaintext highlighter-rouge">/status</code> RPC endpoint. It provides the necessary info:
whenever the node is syncing or not, what height it is on, etc.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http<span class="o">(</span>s<span class="o">)</span>://<span class="o">{</span>ip<span class="o">}</span>:<span class="o">{</span>rpcPort<span class="o">}</span>/status
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">/dump_consensus_state</code> will give you a detailed overview of the consensus
state (proposer, latest validators, peers states). From it, you should be able
to figure out why, for example, the network had halted.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http<span class="o">(</span>s<span class="o">)</span>://<span class="o">{</span>ip<span class="o">}</span>:<span class="o">{</span>rpcPort<span class="o">}</span>/dump_consensus_state
</code></pre></div></div>

<p>There is a reduced version of this endpoint - <code class="language-plaintext highlighter-rouge">/consensus_state</code>, which returns
just the votes seen at the current height.</p>

<p>If, after consulting with the logs and above endpoints, you still have no idea
what’s happening, consider using <code class="language-plaintext highlighter-rouge">tendermint debug kill</code> sub-command. This
command will scrap all the available info and kill the process. See
<a href="/v0.34/tools/debugging.md">Debugging</a> for the exact format.</p>

<p>You can inspect the resulting archive yourself or create an issue on
<a href="https://github.com/tendermint/tendermint">Github</a>. Before opening an issue
however, be sure to check if there’s <a href="https://github.com/tendermint/tendermint/issues">no existing
issue</a> already.</p>

<h2 id="monitoring-tendermint">Monitoring Tendermint</h2>

<p>Each Tendermint instance has a standard <code class="language-plaintext highlighter-rouge">/health</code> RPC endpoint, which responds
with 200 (OK) if everything is fine and 500 (or no response) - if something is
wrong.</p>

<p>Other useful endpoints include mentioned earlier <code class="language-plaintext highlighter-rouge">/status</code>, <code class="language-plaintext highlighter-rouge">/net_info</code> and
<code class="language-plaintext highlighter-rouge">/validators</code>.</p>

<p>Tendermint also can report and serve Prometheus metrics. See
<a href="/v0.34/tendermint-core/metrics/">Metrics</a>.</p>

<p><code class="language-plaintext highlighter-rouge">tendermint debug dump</code> sub-command can be used to periodically dump useful
information into an archive. See <a href="/v0.34/tools/debugging.md">Debugging</a> for more
information.</p>

<h2 id="what-happens-when-my-app-dies">What happens when my app dies</h2>

<p>You are supposed to run Tendermint under a <a href="https://en.wikipedia.org/wiki/Process_supervision">process
supervisor</a> (like
systemd or runit). It will ensure Tendermint is always running (despite
possible errors).</p>

<p>Getting back to the original question, if your application dies,
Tendermint will panic. After a process supervisor restarts your
application, Tendermint should be able to reconnect successfully. The
order of restart does not matter for it.</p>

<h2 id="signal-handling">Signal handling</h2>

<p>We catch SIGINT and SIGTERM and try to clean up nicely. For other
signals we use the default behavior in Go: <a href="https://golang.org/pkg/os/signal/#hdr-Default_behavior_of_signals_in_Go_programs">Default behavior of signals
in Go
programs</a>.</p>

<h2 id="corruption">Corruption</h2>

<p><strong>NOTE:</strong> Make sure you have a backup of the Tendermint data directory.</p>

<h3 id="possible-causes">Possible causes</h3>

<p>Remember that most corruption is caused by hardware issues:</p>

<ul>
  <li>RAID controllers with faulty / worn out battery backup, and an unexpected power loss</li>
  <li>Hard disk drives with write-back cache enabled, and an unexpected power loss</li>
  <li>Cheap SSDs with insufficient power-loss protection, and an unexpected power-loss</li>
  <li>Defective RAM</li>
  <li>Defective or overheating CPU(s)</li>
</ul>

<p>Other causes can be:</p>

<ul>
  <li>Database systems configured with fsync=off and an OS crash or power loss</li>
  <li>Filesystems configured to use write barriers plus a storage layer that ignores write barriers. LVM is a particular culprit.</li>
  <li>Tendermint bugs</li>
  <li>Operating system bugs</li>
  <li>Admin error (e.g., directly modifying Tendermint data-directory contents)</li>
</ul>

<p>(Source: <a href="https://wiki.postgresql.org/wiki/Corruption">https://wiki.postgresql.org/wiki/Corruption</a>)</p>

<h3 id="wal-corruption">WAL Corruption</h3>

<p>If consensus WAL is corrupted at the latest height and you are trying to start
Tendermint, replay will fail with panic.</p>

<p>Recovering from data corruption can be hard and time-consuming. Here are two approaches you can take:</p>

<ol>
  <li>Delete the WAL file and restart Tendermint. It will attempt to sync with other peers.</li>
  <li>Try to repair the WAL file manually:</li>
</ol>

<p>1) Create a backup of the corrupted WAL file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```sh
cp "$TMHOME/data/cs.wal/wal" &gt; /tmp/corrupted_wal_backup
```
</code></pre></div></div>

<p>2) Use <code class="language-plaintext highlighter-rouge">./scripts/wal2json</code> to create a human-readable version:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```sh
./scripts/wal2json/wal2json "$TMHOME/data/cs.wal/wal" &gt; /tmp/corrupted_wal
```
</code></pre></div></div>

<p>3) Search for a “CORRUPTED MESSAGE” line.
4) By looking at the previous message and the message after the corrupted one
   and looking at the logs, try to rebuild the message. If the consequent
   messages are marked as corrupted too (this may happen if length header
   got corrupted or some writes did not make it to the WAL ~ truncation),
   then remove all the lines starting from the corrupted one and restart
   Tendermint.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```sh
$EDITOR /tmp/corrupted_wal
```
</code></pre></div></div>

<p>5) After editing, convert this file back into binary form by running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```sh
./scripts/json2wal/json2wal /tmp/corrupted_wal  $TMHOME/data/cs.wal/wal
```
</code></pre></div></div>

<h2 id="hardware">Hardware</h2>

<h3 id="processor-and-memory">Processor and Memory</h3>

<p>While actual specs vary depending on the load and validators count, minimal
requirements are:</p>

<ul>
  <li>1GB RAM</li>
  <li>25GB of disk space</li>
  <li>1.4 GHz CPU</li>
</ul>

<p>SSD disks are preferable for applications with high transaction throughput.</p>

<p>Recommended:</p>

<ul>
  <li>2GB RAM</li>
  <li>100GB SSD</li>
  <li>x64 2.0 GHz 2v CPU</li>
</ul>

<p>While for now, Tendermint stores all the history and it may require significant
disk space over time, we are planning to implement state syncing (See <a href="https://github.com/tendermint/tendermint/issues/828">this
issue</a>). So, storing all
the past blocks will not be necessary.</p>

<h3 id="validator-signing-on-32-bit-architectures-or-arm">Validator signing on 32 bit architectures (or ARM)</h3>

<p>Both our <code class="language-plaintext highlighter-rouge">ed25519</code> and <code class="language-plaintext highlighter-rouge">secp256k1</code> implementations require constant time
<code class="language-plaintext highlighter-rouge">uint64</code> multiplication. Non-constant time crypto can (and has) leaked
private keys on both <code class="language-plaintext highlighter-rouge">ed25519</code> and <code class="language-plaintext highlighter-rouge">secp256k1</code>. This doesn’t exist in hardware
on 32 bit x86 platforms (<a href="https://bearssl.org/ctmul.html">source</a>), and it
depends on the compiler to enforce that it is constant time. It’s unclear at
this point whenever the Golang compiler does this correctly for all
implementations.</p>

<p><strong>We do not support nor recommend running a validator on 32 bit architectures OR
the “VIA Nano 2000 Series”, and the architectures in the ARM section rated
“S-“.</strong></p>

<h3 id="operating-systems">Operating Systems</h3>

<p>Tendermint can be compiled for a wide range of operating systems thanks to Go
language (the list of $OS/$ARCH pairs can be found
<a href="https://golang.org/doc/install/source#environment">here</a>).</p>

<p>While we do not favor any operation system, more secure and stable Linux server
distributions (like Centos) should be preferred over desktop operation systems
(like Mac OS).</p>

<h3 id="miscellaneous">Miscellaneous</h3>

<p>NOTE: if you are going to use Tendermint in a public domain, make sure
you read <a href="https://cosmos.network/validators">hardware recommendations</a> for a validator in the
Cosmos network.</p>

<h2 id="configuration-parameters">Configuration parameters</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">p2p.flush_throttle_timeout</code></li>
  <li><code class="language-plaintext highlighter-rouge">p2p.max_packet_msg_payload_size</code></li>
  <li><code class="language-plaintext highlighter-rouge">p2p.send_rate</code></li>
  <li><code class="language-plaintext highlighter-rouge">p2p.recv_rate</code></li>
</ul>

<p>If you are going to use Tendermint in a private domain and you have a
private high-speed network among your peers, it makes sense to lower
flush throttle timeout and increase other params.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[p2p]</span>

<span class="py">send_rate</span><span class="p">=</span><span class="mi">20000000</span> <span class="c"># 2MB/s</span>
<span class="py">recv_rate</span><span class="p">=</span><span class="mi">20000000</span> <span class="c"># 2MB/s</span>
<span class="py">flush_throttle_timeout</span><span class="p">=</span><span class="mi">10</span>
<span class="py">max_packet_msg_payload_size</span><span class="p">=</span><span class="mi">10240</span> <span class="c"># 10KB</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mempool.recheck</code></li>
</ul>

<p>After every block, Tendermint rechecks every transaction left in the
mempool to see if transactions committed in that block affected the
application state, so some of the transactions left may become invalid.
If that does not apply to your application, you can disable it by
setting <code class="language-plaintext highlighter-rouge">mempool.recheck=false</code>.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mempool.broadcast</code></li>
</ul>

<p>Setting this to false will stop the mempool from relaying transactions
to other peers until they are included in a block. It means only the
peer you send the tx to will see it until it is included in a block.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">consensus.skip_timeout_commit</code></li>
</ul>

<p>We want <code class="language-plaintext highlighter-rouge">skip_timeout_commit=false</code> when there is economics on the line
because proposers should wait to hear for more votes. But if you don’t
care about that and want the fastest consensus, you can skip it. It will
be kept false by default for public deployments (e.g. <a href="https://hub.cosmos.network/">Cosmos
Hub</a>) while for enterprise
applications, setting it to true is not a problem.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">consensus.peer_gossip_sleep_duration</code></li>
</ul>

<p>You can try to reduce the time your node sleeps before checking if
theres something to send its peers.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">consensus.timeout_commit</code></li>
</ul>

<p>You can also try lowering <code class="language-plaintext highlighter-rouge">timeout_commit</code> (time we sleep before
proposing the next block).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">p2p.addr_book_strict</code></li>
</ul>

<p>By default, Tendermint checks whenever a peer’s address is routable before
saving it to the address book. The address is considered as routable if the IP
is <a href="https://github.com/tendermint/tendermint/blob/27bd1deabe4ba6a2d9b463b8f3e3f1e31b993e61/p2p/netaddress.go#L209">valid and within allowed
ranges</a>.</p>

<p>This may not be the case for private or local networks, where your IP range is usually
strictly limited and private. If that case, you need to set <code class="language-plaintext highlighter-rouge">addr_book_strict</code>
to <code class="language-plaintext highlighter-rouge">false</code> (turn it off).</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">rpc.max_open_connections</code></li>
</ul>

<p>By default, the number of simultaneous connections is limited because most OS
give you limited number of file descriptors.</p>

<p>If you want to accept greater number of connections, you will need to increase
these limits.</p>

<p><a href="https://github.com/satori-com/tcpkali/blob/master/doc/tcpkali.man.md#sysctls-to-tune-the-system-to-be-able-to-open-more-connections">Sysctls to tune the system to be able to open more connections</a></p>

<p>The process file limits must also be increased, e.g. via <code class="language-plaintext highlighter-rouge">ulimit -n 8192</code>.</p>

<p>…for N connections, such as 50k:</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kern.maxfiles=10000+2<span class="err">*</span>N         # BSD
kern.maxfilesperproc=100+2<span class="err">*</span>N    # BSD
kern.ipc.maxsockets=10000+2<span class="err">*</span>N   # BSD
fs.file-max=10000+2<span class="err">*</span>N           # Linux
net.ipv4.tcp_max_orphans=N      # Linux

<span class="gh"># For load-generating clients.</span>
net.ipv4.ip_local_port_range="10000  65535"  # Linux.
net.inet.ip.portrange.first=10000  # BSD/Mac.
net.inet.ip.portrange.last=65535   # (Enough for N &lt; 55535)
net.ipv4.tcp_tw_reuse=1         # Linux
net.inet.tcp.maxtcptw=2<span class="err">*</span>N       # BSD

<span class="gh"># If using netfilter on Linux:</span>
net.netfilter.nf_conntrack_max=N
echo $((N/8)) &gt; /sys/module/nf_conntrack/parameters/hashsize
</code></pre></div></div>

<p>The similar option exists for limiting the number of gRPC connections -
<code class="language-plaintext highlighter-rouge">rpc.grpc_max_open_connections</code>.</p>
:ET