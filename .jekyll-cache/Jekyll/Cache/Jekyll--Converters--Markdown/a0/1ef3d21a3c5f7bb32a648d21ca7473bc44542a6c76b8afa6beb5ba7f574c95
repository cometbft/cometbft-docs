I"ñB<h1 id="what-is-tendermint">What is Tendermint</h1>

<p>Tendermint is software for securely and consistently replicating an
application on many machines. By securely, we mean that Tendermint works
as long as less than 1/3 of machines fail in arbitrary ways. By consistently,
we mean that every non-faulty machine sees the same transaction log and
computes the same state. Secure and consistent replication is a
fundamental problem in distributed systems; it plays a critical role in
the fault tolerance of a broad range of applications, from currencies,
to elections, to infrastructure orchestration, and beyond.</p>

<p>The ability to tolerate machines failing in arbitrary ways, including
becoming malicious, is known as Byzantine fault tolerance (BFT). The
theory of BFT is decades old, but software implementations have only
became popular recently, due largely to the success of ‚Äúblockchain
technology‚Äù like Bitcoin and Ethereum. Blockchain technology is just a
reformalization of BFT in a more modern setting, with emphasis on
peer-to-peer networking and cryptographic authentication. The name
derives from the way transactions are batched in blocks, where each
block contains a cryptographic hash of the previous one, forming a
chain.</p>

<p>Tendermint consists of two chief technical components: a blockchain
consensus engine and a generic application interface. The consensus
engine, called Tendermint Core, ensures that the same transactions are
recorded on every machine in the same order. The application interface,
called the Application BlockChain Interface (ABCI), delivers the transactions
to applications for processing. Unlike other
blockchain and consensus solutions, which come pre-packaged with built
in state machines (like a fancy key-value store, or a quirky scripting
language), developers can use Tendermint for BFT state machine
replication of applications written in whatever programming language and
development environment is right for them.</p>

<p>Tendermint is designed to be easy-to-use, simple-to-understand, highly
performant, and useful for a wide variety of distributed applications.</p>

<h2 id="tendermint-vs-x">Tendermint vs. X</h2>

<p>Tendermint is broadly similar to two classes of software. The first
class consists of distributed key-value stores, like Zookeeper, etcd,
and consul, which use non-BFT consensus. The second class is known as
‚Äúblockchain technology‚Äù, and consists of both cryptocurrencies like
Bitcoin and Ethereum, and alternative distributed ledger designs like
Hyperledger‚Äôs Burrow.</p>

<h3 id="zookeeper-etcd-consul">Zookeeper, etcd, consul</h3>

<p>Zookeeper, etcd, and consul are all implementations of key-value stores
atop a classical, non-BFT consensus algorithm. Zookeeper uses an
algorithm called Zookeeper Atomic Broadcast, while etcd and consul use
the Raft log replication algorithm. A
typical cluster contains 3-5 machines, and can tolerate crash failures
in less than 1/2 of the machines (e.g., 1 out of 3 or 2 out of 5),
but even a single Byzantine fault can jeopardize the whole system.</p>

<p>Each offering provides a slightly different implementation of a
featureful key-value store, but all are generally focused around
providing basic services to distributed systems, such as dynamic
configuration, service discovery, locking, leader-election, and so on.</p>

<p>Tendermint is in essence similar software, but with two key differences:</p>

<ul>
  <li>It is Byzantine Fault Tolerant, meaning it can only tolerate less than 1/3
of machines failing, but those failures can include arbitrary behavior -
including hacking and malicious attacks. - It does not specify a
particular application, like a fancy key-value store. Instead, it
focuses on arbitrary state machine replication, so developers can build
the application logic that‚Äôs right for them, from key-value store to
cryptocurrency to e-voting platform and beyond.</li>
</ul>

<h3 id="bitcoin-ethereum-etc">Bitcoin, Ethereum, etc</h3>

<p>Tendermint emerged in the tradition of cryptocurrencies like Bitcoin,
Ethereum, etc. with the goal of providing a more efficient and secure
consensus algorithm than Bitcoin‚Äôs Proof of Work. In the early days,
Tendermint had a simple currency built in, and to participate in
consensus, users had to ‚Äúbond‚Äù units of the currency into a security
deposit which could be revoked if they misbehaved -this is what made
Tendermint a Proof-of-Stake algorithm.</p>

<p>Since then, Tendermint has evolved to be a general purpose blockchain
consensus engine that can host arbitrary application states. That means
it can be used as a plug-and-play replacement for the consensus engines
of other blockchain software. So one can take the current Ethereum code
base, whether in Rust, or Go, or Haskell, and run it as a ABCI
application using Tendermint consensus. Indeed, <a href="https://github.com/cosmos/ethermint">we did that with
Ethereum</a>. And we plan to do
the same for Bitcoin, ZCash, and various other deterministic
applications as well.</p>

<p>Another example of a cryptocurrency application built on Tendermint is
<a href="http://cosmos.network">the Cosmos network</a>.</p>

<h3 id="other-blockchain-projects">Other Blockchain Projects</h3>

<p><a href="https://github.com/hyperledger/fabric">Fabric</a> takes a similar approach
to Tendermint, but is more opinionated about how the state is managed,
and requires that all application behavior runs in potentially many
docker containers, modules it calls ‚Äúchaincode‚Äù. It uses an
implementation of <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">PBFT</a>.
from a team at IBM that is <a href="https://drops.dagstuhl.de/opus/volltexte/2017/7093/pdf/LIPIcs-OPODIS-2016-24.pdf">augmented to handle potentially
non-deterministic
chaincode</a>.
It is possible to implement this docker-based behavior as an ABCI app in
Tendermint, though extending Tendermint to handle non-determinism
remains for future work.</p>

<p><a href="https://github.com/hyperledger/burrow">Burrow</a> is an implementation of
the Ethereum Virtual Machine and Ethereum transaction mechanics, with
additional features for a name-registry, permissions, and native
contracts, and an alternative blockchain API. It uses Tendermint as its
consensus engine, and provides a particular application state.</p>

<h2 id="abci-overview">ABCI Overview</h2>

<p>The <a href="https://github.com/tendermint/tendermint/tree/main/abci">Application BlockChain Interface
(ABCI)</a>
allows for Byzantine Fault Tolerant replication of applications
written in any programming language.</p>

<h3 id="motivation">Motivation</h3>

<p>Thus far, all blockchains ‚Äústacks‚Äù (such as
<a href="https://github.com/bitcoin/bitcoin">Bitcoin</a>) have had a monolithic
design. That is, each blockchain stack is a single program that handles
all the concerns of a decentralized ledger; this includes P2P
connectivity, the ‚Äúmempool‚Äù broadcasting of transactions, consensus on
the most recent block, account balances, Turing-complete contracts,
user-level permissions, etc.</p>

<p>Using a monolithic architecture is typically bad practice in computer
science. It makes it difficult to reuse components of the code, and
attempts to do so result in complex maintenance procedures for forks of
the codebase. This is especially true when the codebase is not modular
in design and suffers from ‚Äúspaghetti code‚Äù.</p>

<p>Another problem with monolithic design is that it limits you to the
language of the blockchain stack (or vice versa). In the case of
Ethereum which supports a Turing-complete bytecode virtual-machine, it
limits you to languages that compile down to that bytecode; while the
<a href="https://github.com/pirapira/awesome-ethereum-virtual-machine#programming-languages-that-compile-into-evm">list</a>
is growing, it is still very limited.</p>

<p>In contrast, our approach is to decouple the consensus engine and P2P
layers from the details of the state of the particular
blockchain application. We do this by abstracting away the details of
the application to an interface, which is implemented as a socket
protocol.</p>

<h3 id="intro-to-abci">Intro to ABCI</h3>

<p><a href="https://github.com/tendermint/tendermint">Tendermint Core</a>, the
‚Äúconsensus engine‚Äù, communicates with the application via a socket
protocol that satisfies the ABCI, the Tendermint Socket Protocol
(TSP, or Teaspoon).</p>

<p>To draw an analogy, lets talk about a well-known cryptocurrency,
Bitcoin. Bitcoin is a cryptocurrency blockchain where each node
maintains a fully audited Unspent Transaction Output (UTXO) database. If
one wanted to create a Bitcoin-like system on top of ABCI, Tendermint
Core would be responsible for</p>

<ul>
  <li>Sharing blocks and transactions between nodes</li>
  <li>Establishing a canonical/immutable order of transactions
(the blockchain)</li>
</ul>

<p>The application will be responsible for</p>

<ul>
  <li>Maintaining the UTXO database</li>
  <li>Validating cryptographic signatures of transactions</li>
  <li>Preventing transactions from spending non-existent transactions</li>
  <li>Allowing clients to query the UTXO database.</li>
</ul>

<p>Tendermint is able to decompose the blockchain design by offering a very
simple API (i.e. the ABCI) between the application process and consensus
process.</p>

<p>The ABCI consists of 3 primary message types that get delivered from the
core to the application. The application replies with corresponding
response messages.</p>

<p>The messages are specified here: <a href="https://github.com/tendermint/tendermint/blob/main/abci/README.md#message-types">ABCI Message
Types</a>.</p>

<p>The <strong>DeliverTx</strong> message is the work horse of the application. Each
transaction in the blockchain is delivered with this message. The
application needs to validate each transaction received with the
<strong>DeliverTx</strong> message against the current state, application protocol,
and the cryptographic credentials of the transaction. A validated
transaction then needs to update the application state ‚Äî by binding a
value into a key values store, or by updating the UTXO database, for
instance.</p>

<p>The <strong>CheckTx</strong> message is similar to <strong>DeliverTx</strong>, but it‚Äôs only for
validating transactions. Tendermint Core‚Äôs mempool first checks the
validity of a transaction with <strong>CheckTx</strong>, and only relays valid
transactions to its peers. For instance, an application may check an
incrementing sequence number in the transaction and return an error upon
<strong>CheckTx</strong> if the sequence number is old. Alternatively, they might use
a capabilities based system that requires capabilities to be renewed
with every transaction.</p>

<p>The <strong>Commit</strong> message is used to compute a cryptographic commitment to
the current application state, to be placed into the next block header.
This has some handy properties. Inconsistencies in updating that state
will now appear as blockchain forks which catches a whole class of
programming errors. This also simplifies the development of secure
lightweight clients, as Merkle-hash proofs can be verified by checking
against the block hash, and that the block hash is signed by a quorum.</p>

<p>There can be multiple ABCI socket connections to an application.
Tendermint Core creates three ABCI connections to the application; one
for the validation of transactions when broadcasting in the mempool, one
for the consensus engine to run block proposals, and one more for
querying the application state.</p>

<p>It‚Äôs probably evident that applications designers need to very carefully
design their message handlers to create a blockchain that does anything
useful but this architecture provides a place to start. The diagram
below illustrates the flow of messages via ABCI.</p>

<p><img src="/v0.37/imgs/abci.png" alt="abci" /></p>

<h2 id="a-note-on-determinism">A Note on Determinism</h2>

<p>The logic for blockchain transaction processing must be deterministic.
If the application logic weren‚Äôt deterministic, consensus would not be
reached among the Tendermint Core replica nodes.</p>

<p>Solidity on Ethereum is a great language of choice for blockchain
applications because, among other reasons, it is a completely
deterministic programming language. However, it‚Äôs also possible to
create deterministic applications using existing popular languages like
Java, C++, Python, or Go, by avoiding
sources of non-determinism such as:</p>

<ul>
  <li>random number generators (without deterministic seeding)</li>
  <li>race conditions on threads (or avoiding threads altogether)</li>
  <li>the system clock</li>
  <li>uninitialized memory (in unsafe programming languages like C
or C++)</li>
  <li><a href="http://gafferongames.com/networking-for-game-programmers/floating-point-determinism/">floating point
arithmetic</a></li>
  <li>language features that are random (e.g. map iteration in Go)</li>
</ul>

<p>While programmers can avoid non-determinism by being careful, it is also
possible to create a special linter or static analyzer for each language
to check for determinism. In the future we may work with partners to
create such tools.</p>

<h2 id="consensus-overview">Consensus Overview</h2>

<p>Tendermint is an easy-to-understand, mostly asynchronous, BFT consensus
protocol. The protocol follows a simple state machine that looks like
this:</p>

<p><img src="/v0.37/imgs/consensus_logic.png" alt="consensus-logic" /></p>

<p>Participants in the protocol are called <strong>validators</strong>; they take turns
proposing blocks of transactions and voting on them. Blocks are
committed in a chain, with one block at each <strong>height</strong>. A block may
fail to be committed, in which case the protocol moves to the next
<strong>round</strong>, and a new validator gets to propose a block for that height.
Two stages of voting are required to successfully commit a block; we
call them <strong>pre-vote</strong> and <strong>pre-commit</strong>.</p>

<p>There is a picture of a couple doing the polka because validators are
doing something like a polka dance. When more than two-thirds of the
validators pre-vote for the same block, we call that a <strong>polka</strong>. Every
pre-commit must be justified by a polka in the same round.
A block is committed when
more than 2/3 of validators pre-commit for the same block in the same
round.</p>

<p>Validators may fail to commit a block for a number of reasons; the
current proposer may be offline, or the network may be slow. Tendermint
allows them to establish that a validator should be skipped. Validators
wait a small amount of time to receive a complete proposal block from
the proposer before voting to move to the next round. This reliance on a
timeout is what makes Tendermint a weakly synchronous protocol, rather
than an asynchronous one. However, the rest of the protocol is
asynchronous, and validators only make progress after hearing from more
than two-thirds of the validator set. A simplifying element of
Tendermint is that it uses the same mechanism to commit a block as it
does to skip to the next round.</p>

<p>Assuming less than one-third of the validators are Byzantine, Tendermint
guarantees that safety will never be violated - that is, validators will
never commit conflicting blocks at the same height. To do this it
introduces a few <strong>locking</strong> rules which modulate which paths can be
followed in the flow diagram. Once a validator precommits a block, it is
locked on that block. Then,</p>

<ol>
  <li>it must prevote for the block it is locked on</li>
  <li>it can only unlock, and precommit for a new block, if there is a
 polka for that block in a later round</li>
</ol>

<h2 id="stake">Stake</h2>

<p>In many systems, not all validators will have the same ‚Äúweight‚Äù in the
consensus protocol. Thus, we are not so much interested in one-third or
two-thirds of the validators, but in those proportions of the total
voting power, which may not be uniformly distributed across individual
validators.</p>

<p>Since Tendermint can replicate arbitrary applications, it is possible to
define a currency, and denominate the voting power in that currency.
When voting power is denominated in a native currency, the system is
often referred to as Proof-of-Stake. Validators can be forced, by logic
in the application, to ‚Äúbond‚Äù their currency holdings in a security
deposit that can be destroyed if they‚Äôre found to misbehave in the
consensus protocol. This adds an economic element to the security of the
protocol, allowing one to quantify the cost of violating the assumption
that less than one-third of voting power is Byzantine.</p>

<p>The <a href="https://cosmos.network">Cosmos Network</a> is designed to use this
Proof-of-Stake mechanism across an array of cryptocurrencies implemented
as ABCI applications.</p>

<p>The following diagram is Tendermint in a (technical) nutshell.</p>

<p><img src="/v0.37/imgs/tm-transaction-flow.png" alt="tx-flow" /></p>
:ET