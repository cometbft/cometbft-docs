I"˜<h1 id="core-verification">Core Verification</h1>

<h2 id="problem-statement">Problem statement</h2>

<p>We assume that the light client knows a (base) header <code class="language-plaintext highlighter-rouge">inithead</code> it trusts (by social consensus or because
the light client has decided to trust the header before). The goal is to check whether another header
<code class="language-plaintext highlighter-rouge">newhead</code> can be trusted based on the data in <code class="language-plaintext highlighter-rouge">inithead</code>.</p>

<p>The correctness of the protocol is based on the assumption that <code class="language-plaintext highlighter-rouge">inithead</code> was generated by an instance of
Tendermint consensus.</p>

<h3 id="failure-model">Failure Model</h3>

<p>For the purpose of the following definitions we assume that there exists a function
<code class="language-plaintext highlighter-rouge">validators</code> that returns the corresponding validator set for the given hash.</p>

<p>The light client protocol is defined with respect to the following failure model:</p>

<p>Given a known bound <code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD</code>, and a block <code class="language-plaintext highlighter-rouge">b</code> with header <code class="language-plaintext highlighter-rouge">h</code> generated at time <code class="language-plaintext highlighter-rouge">Time</code>
(i.e. <code class="language-plaintext highlighter-rouge">h.Time = Time</code>), a set of validators that hold more than 2/3 of the voting power
in <code class="language-plaintext highlighter-rouge">validators(b.Header.NextValidatorsHash)</code> is correct until time <code class="language-plaintext highlighter-rouge">b.Header.Time + TRUSTED_PERIOD</code>.</p>

<p><em>Assumption</em>: ‚Äúcorrect‚Äù is defined w.r.t. realtime (some Newtonian global notion of time, i.e., wall time),
while <code class="language-plaintext highlighter-rouge">Header.Time</code> corresponds to the <a href="/v0.34/spec/consensus/bft-time/">BFT time</a>. In this note, we assume that clocks of correct processes
are synchronized (for example using NTP), and therefore there is bounded clock drift (<code class="language-plaintext highlighter-rouge">CLOCK_DRIFT</code>) between local clocks and
BFT time. More precisely, for every correct light client process and every <code class="language-plaintext highlighter-rouge">header.Time</code> (i.e. BFT Time, for a header correctly
generated by the Tendermint consensus), the following inequality holds: <code class="language-plaintext highlighter-rouge">Header.Time &lt; now + CLOCK_DRIFT</code>,
where <code class="language-plaintext highlighter-rouge">now</code> corresponds to the system clock at the light client process.</p>

<p>Furthermore, we assume that <code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD</code> is (several) order of magnitude bigger than <code class="language-plaintext highlighter-rouge">CLOCK_DRIFT</code> (<code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD &gt;&gt; CLOCK_DRIFT</code>),
as <code class="language-plaintext highlighter-rouge">CLOCK_DRIFT</code> (using NTP) is in the order of milliseconds and <code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD</code> is in the order of weeks.</p>

<p>We expect a light client process defined in this document to be used in the context in which there is some
larger period during which misbehaving validators can be detected and punished (we normally refer to it as <code class="language-plaintext highlighter-rouge">UNBONDING_PERIOD</code>
due to the ‚Äúbonding‚Äù mechanism in modern proof of stake systems). Furthermore, we assume that
<code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD &lt; UNBONDING_PERIOD</code> and that they are normally of the same order of magnitude, for example
<code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD = UNBONDING_PERIOD / 2</code>.</p>

<p>The specification in this document considers an implementation of the light client under the Failure Model defined above.
Mechanisms like <code class="language-plaintext highlighter-rouge">fork accountability</code> and <code class="language-plaintext highlighter-rouge">evidence submission</code> are defined in the context of <code class="language-plaintext highlighter-rouge">UNBONDING_PERIOD</code> and
they incentivize validators to follow the protocol specification defined in this document. If they don‚Äôt,
and we have 1/3 (or more) faulty validators, safety may be violated. Our approach then is
to <em>detect</em> these cases (after the fact), and take suitable repair actions (automatic and social).
This is discussed in document on <a href="/v0.34/spec/consensus/light-client/accountability.md">Fork accountability</a>.</p>

<p>The term ‚Äútrusted‚Äù above indicates that the correctness of the protocol depends on
this assumption. It is in the responsibility of the user that runs the light client to make sure that the risk
of trusting a corrupted/forged <code class="language-plaintext highlighter-rouge">inithead</code> is negligible.</p>

<p><em>Remark</em>: This failure model might change to a hybrid version that takes heights into account in the future.</p>

<h3 id="high-level-solution">High Level Solution</h3>

<p>Upon initialization, the light client is given a header <code class="language-plaintext highlighter-rouge">inithead</code> it trusts (by
social consensus). When a light clients sees a new signed header <code class="language-plaintext highlighter-rouge">snh</code>, it has to decide whether to trust the new
header. Trust can be obtained by (possibly) the combination of three methods.</p>

<ol>
  <li>
    <p><strong>Uninterrupted sequence of headers.</strong> Given a trusted header <code class="language-plaintext highlighter-rouge">h</code> and an untrusted header <code class="language-plaintext highlighter-rouge">h1</code>,
the light client trusts a header <code class="language-plaintext highlighter-rouge">h1</code> if it trusts all headers in between <code class="language-plaintext highlighter-rouge">h</code> and <code class="language-plaintext highlighter-rouge">h1</code>.</p>
  </li>
  <li>
    <p><strong>Trusted period.</strong> Given a trusted header <code class="language-plaintext highlighter-rouge">h</code>, an untrusted header <code class="language-plaintext highlighter-rouge">h1 &gt; h</code> and <code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD</code> during which
the failure model holds, we can check whether at least one validator, that has been continuously correct
from <code class="language-plaintext highlighter-rouge">h.Time</code> until now, has signed <code class="language-plaintext highlighter-rouge">h1</code>. If this is the case, we can trust <code class="language-plaintext highlighter-rouge">h1</code>.</p>
  </li>
  <li>
    <p><strong>Bisection.</strong> If a check according to 2. (trusted period) fails, the light client can try to
obtain a header <code class="language-plaintext highlighter-rouge">hp</code> whose height lies between <code class="language-plaintext highlighter-rouge">h</code> and <code class="language-plaintext highlighter-rouge">h1</code> in order to check whether <code class="language-plaintext highlighter-rouge">h</code> can be used to
get trust for <code class="language-plaintext highlighter-rouge">hp</code>, and <code class="language-plaintext highlighter-rouge">hp</code> can be used to get trust for <code class="language-plaintext highlighter-rouge">snh</code>. If this is the case we can trust <code class="language-plaintext highlighter-rouge">h1</code>;
if not, we continue recursively until either we found set of headers that can build (transitively) trust relation
between <code class="language-plaintext highlighter-rouge">h</code> and <code class="language-plaintext highlighter-rouge">h1</code>, or we failed as two consecutive headers don‚Äôt verify against each other.</p>
  </li>
</ol>

<h2 id="definitions">Definitions</h2>

<h3 id="data-structures">Data structures</h3>

<p>In the following, only the details of the data structures needed for this specification are given.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">type</span> <span class="n">Header</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Height</span>               <span class="kt">int64</span>
        <span class="n">Time</span>                 <span class="n">Time</span>          <span class="c">// the chain time when the header (block) was generated</span>

        <span class="n">LastBlockID</span>          <span class="n">BlockID</span>       <span class="c">// prev block info</span>
        <span class="n">ValidatorsHash</span>       <span class="p">[]</span><span class="kt">byte</span>        <span class="c">// hash of the validators for the current block</span>
        <span class="n">NextValidatorsHash</span>   <span class="p">[]</span><span class="kt">byte</span>        <span class="c">// hash of the validators for the next block</span>
   <span class="p">}</span>

   <span class="k">type</span> <span class="n">SignedHeader</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Header</span>        <span class="n">Header</span>
        <span class="n">Commit</span>        <span class="n">Commit</span>            <span class="c">// commit for the given header</span>
   <span class="p">}</span>

   <span class="k">type</span> <span class="n">ValidatorSet</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Validators</span>         <span class="p">[]</span><span class="n">Validator</span>
        <span class="n">TotalVotingPower</span>   <span class="kt">int64</span>
   <span class="p">}</span>

   <span class="k">type</span> <span class="n">Validator</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">Address</span>       <span class="n">Address</span>           <span class="c">// validator address (we assume validator's addresses are unique)</span>
        <span class="n">VotingPower</span>   <span class="kt">int64</span>             <span class="c">// validator's voting power</span>
   <span class="p">}</span>

   <span class="k">type</span> <span class="n">TrustedState</span> <span class="p">{</span>
        <span class="n">SignedHeader</span>   <span class="n">SignedHeader</span>
        <span class="n">ValidatorSet</span>   <span class="n">ValidatorSet</span>
   <span class="p">}</span>
</code></pre></div></div>

<h3 id="functions">Functions</h3>

<p>For the purpose of this light client specification, we assume that the Cosmos Full Node
exposes the following functions over RPC:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">// returns signed header: Header with Commit, for the given height</span>
    <span class="k">func</span> <span class="n">Commit</span><span class="p">(</span><span class="n">height</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="n">SignedHeader</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c">// returns validator set for the given height</span>
    <span class="k">func</span> <span class="n">Validators</span><span class="p">(</span><span class="n">height</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="n">ValidatorSet</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div>

<p>Furthermore, we assume the following auxiliary functions:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">// returns true if the commit is for the header, ie. if it contains</span>
    <span class="c">// the correct hash of the header; otherwise false</span>
    <span class="k">func</span> <span class="n">matchingCommit</span><span class="p">(</span><span class="n">header</span> <span class="n">Header</span><span class="p">,</span> <span class="n">commit</span> <span class="n">Commit</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c">// returns the set of validators from the given validator set that</span>
    <span class="c">// committed the block (that correctly signed the block)</span>
    <span class="c">// it assumes signature verification so it can be computationally expensive</span>
    <span class="k">func</span> <span class="n">signers</span><span class="p">(</span><span class="n">commit</span> <span class="n">Commit</span><span class="p">,</span> <span class="n">validatorSet</span> <span class="n">ValidatorSet</span><span class="p">)</span> <span class="p">[]</span><span class="n">Validator</span>

    <span class="c">// returns the voting power the validators in v1 have according to their voting power in set v2</span>
    <span class="c">// it does not assume signature verification</span>
    <span class="k">func</span> <span class="n">votingPowerIn</span><span class="p">(</span><span class="n">v1</span> <span class="p">[]</span><span class="n">Validator</span><span class="p">,</span> <span class="n">v2</span> <span class="n">ValidatorSet</span><span class="p">)</span> <span class="kt">int64</span>

    <span class="c">// returns hash of the given validator set</span>
    <span class="k">func</span> <span class="n">hash</span><span class="p">(</span><span class="n">v2</span> <span class="n">ValidatorSet</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
</code></pre></div></div>

<p>In the functions below we will be using <code class="language-plaintext highlighter-rouge">trustThreshold</code> as a parameter. For simplicity
we assume that <code class="language-plaintext highlighter-rouge">trustThreshold</code> is a float between <code class="language-plaintext highlighter-rouge">1/3</code> and <code class="language-plaintext highlighter-rouge">2/3</code> and we will not be checking it
in the pseudo-code.</p>

<p><strong>VerifySingle.</strong> The function <code class="language-plaintext highlighter-rouge">VerifySingle</code> attempts to validate given untrusted header and the corresponding validator sets
based on a given trusted state. It ensures that the trusted state is still within its trusted period,
and that the untrusted header is within assumed <code class="language-plaintext highlighter-rouge">clockDrift</code> bound of the passed time <code class="language-plaintext highlighter-rouge">now</code>.
Note that this function is not making external (RPC) calls to the full node; the whole logic is
based on the local (given) state. This function is supposed to be used by the IBC handlers.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">VerifySingle</span><span class="p">(</span><span class="n">untrustedSh</span> <span class="n">SignedHeader</span><span class="p">,</span>
                  <span class="n">untrustedVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                  <span class="n">untrustedNextVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                  <span class="n">trustedState</span> <span class="n">TrustedState</span><span class="p">,</span>
                  <span class="n">trustThreshold</span> <span class="n">float</span><span class="p">,</span>
                  <span class="n">trustingPeriod</span> <span class="n">Duration</span><span class="p">,</span>
                  <span class="n">clockDrift</span> <span class="n">Duration</span><span class="p">,</span>
                  <span class="n">now</span> <span class="n">Time</span><span class="p">)</span> <span class="p">(</span><span class="n">TrustedState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="n">untrustedSh</span><span class="o">.</span><span class="n">Header</span><span class="o">.</span><span class="n">Time</span> <span class="o">&gt;</span> <span class="n">now</span> <span class="o">+</span> <span class="n">clockDrift</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrInvalidHeaderTime</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">trustedHeader</span> <span class="o">=</span> <span class="n">trustedState</span><span class="o">.</span><span class="n">SignedHeader</span><span class="o">.</span><span class="n">Header</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">trustedHeader</span><span class="p">,</span> <span class="n">trustingPeriod</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// we assume that time it takes to execute verifySingle function</span>
    <span class="c">// is several order of magnitudes smaller than trustingPeriod</span>
    <span class="kt">error</span> <span class="o">=</span> <span class="n">verifySingle</span><span class="p">(</span>
                <span class="n">trustedState</span><span class="p">,</span>
                <span class="n">untrustedSh</span><span class="p">,</span>
                <span class="n">untrustedVs</span><span class="p">,</span>
                <span class="n">untrustedNextVs</span><span class="p">,</span>
                <span class="n">trustThreshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c">// the untrusted header is now trusted</span>
    <span class="n">newTrustedState</span> <span class="o">=</span> <span class="n">TrustedState</span><span class="p">(</span><span class="n">untrustedSh</span><span class="p">,</span> <span class="n">untrustedNextVs</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">newTrustedState</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// return true if header is within its light client trusted period; otherwise returns false</span>
<span class="k">func</span> <span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">header</span> <span class="n">Header</span><span class="p">,</span>
                           <span class="n">trustingPeriod</span> <span class="n">Duration</span><span class="p">,</span>
                           <span class="n">now</span> <span class="n">Time</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">header</span><span class="o">.</span><span class="n">Time</span> <span class="o">+</span> <span class="n">trustedPeriod</span> <span class="o">&gt;</span> <span class="n">now</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that in case <code class="language-plaintext highlighter-rouge">VerifySingle</code> returns without an error (untrusted header
is successfully verified) then we have a guarantee that the transition of the trust
from <code class="language-plaintext highlighter-rouge">trustedState</code> to <code class="language-plaintext highlighter-rouge">newTrustedState</code> happened during the trusted period of
<code class="language-plaintext highlighter-rouge">trustedState.SignedHeader.Header</code>.</p>

<p>TODO: Explain what happens in case <code class="language-plaintext highlighter-rouge">VerifySingle</code> returns with an error.</p>

<p><strong>verifySingle.</strong> The function <code class="language-plaintext highlighter-rouge">verifySingle</code> verifies a single untrusted header
against a given trusted state. It includes all validations and signature verification.
It is not publicly exposed since it does not check for header expiry (time constraints)
and hence it‚Äôs possible to use it incorrectly.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">verifySingle</span><span class="p">(</span><span class="n">trustedState</span> <span class="n">TrustedState</span><span class="p">,</span>
                  <span class="n">untrustedSh</span> <span class="n">SignedHeader</span><span class="p">,</span>
                  <span class="n">untrustedVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                  <span class="n">untrustedNextVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                  <span class="n">trustThreshold</span> <span class="n">float</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>

    <span class="n">untrustedHeader</span> <span class="o">=</span> <span class="n">untrustedSh</span><span class="o">.</span><span class="n">Header</span>
    <span class="n">untrustedCommit</span> <span class="o">=</span> <span class="n">untrustedSh</span><span class="o">.</span><span class="n">Commit</span>

    <span class="n">trustedHeader</span> <span class="o">=</span> <span class="n">trustedState</span><span class="o">.</span><span class="n">SignedHeader</span><span class="o">.</span><span class="n">Header</span>
    <span class="n">trustedVs</span> <span class="o">=</span> <span class="n">trustedState</span><span class="o">.</span><span class="n">ValidatorSet</span>

    <span class="k">if</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">&gt;=</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="k">return</span> <span class="n">ErrNonIncreasingHeight</span>
    <span class="k">if</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Time</span> <span class="o">&gt;=</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Time</span> <span class="k">return</span> <span class="n">ErrNonIncreasingTime</span>

    <span class="c">// validate the untrusted header against its commit, vals, and next_vals</span>
    <span class="kt">error</span> <span class="o">=</span> <span class="n">validateSignedHeaderAndVals</span><span class="p">(</span><span class="n">untrustedSh</span><span class="p">,</span> <span class="n">untrustedVs</span><span class="p">,</span> <span class="n">untrustedNextVs</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="kt">error</span>

    <span class="c">// check for adjacent headers</span>
    <span class="k">if</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">==</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">+</span> <span class="m">1</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">NextValidatorsHash</span> <span class="o">!=</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">ValidatorsHash</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">ErrInvalidAdjacentHeaders</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">error</span> <span class="o">=</span> <span class="n">verifyCommitTrusting</span><span class="p">(</span><span class="n">trustedVs</span><span class="p">,</span> <span class="n">untrustedCommit</span><span class="p">,</span> <span class="n">untrustedVs</span><span class="p">,</span> <span class="n">trustThreshold</span><span class="p">)</span>
        <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c">// verify the untrusted commit</span>
    <span class="k">return</span> <span class="n">verifyCommitFull</span><span class="p">(</span><span class="n">untrustedVs</span><span class="p">,</span> <span class="n">untrustedCommit</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// returns nil if header and validator sets are consistent; otherwise returns error</span>
<span class="k">func</span> <span class="n">validateSignedHeaderAndVals</span><span class="p">(</span><span class="n">signedHeader</span> <span class="n">SignedHeader</span><span class="p">,</span> <span class="n">vs</span> <span class="n">ValidatorSet</span><span class="p">,</span> <span class="n">nextVs</span> <span class="n">ValidatorSet</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">signedHeader</span><span class="o">.</span><span class="n">Header</span>
    <span class="k">if</span> <span class="n">hash</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">header</span><span class="o">.</span><span class="n">ValidatorsHash</span> <span class="k">return</span> <span class="n">ErrInvalidValidatorSet</span>
    <span class="k">if</span> <span class="n">hash</span><span class="p">(</span><span class="n">nextVs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">header</span><span class="o">.</span><span class="n">NextValidatorsHash</span> <span class="k">return</span> <span class="n">ErrInvalidNextValidatorSet</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">matchingCommit</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">signedHeader</span><span class="o">.</span><span class="n">Commit</span><span class="p">)</span> <span class="k">return</span> <span class="n">ErrInvalidCommitValue</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// returns nil if at least single correst signer signed the commit; otherwise returns error</span>
<span class="k">func</span> <span class="n">verifyCommitTrusting</span><span class="p">(</span><span class="n">trustedVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                          <span class="n">commit</span> <span class="n">Commit</span><span class="p">,</span>
                          <span class="n">untrustedVs</span> <span class="n">ValidatorSet</span><span class="p">,</span>
                          <span class="n">trustLevel</span> <span class="n">float</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>

    <span class="n">totalPower</span> <span class="o">:=</span> <span class="n">trustedVs</span><span class="o">.</span><span class="n">TotalVotingPower</span>
    <span class="n">signedPower</span> <span class="o">:=</span> <span class="n">votingPowerIn</span><span class="p">(</span><span class="n">signers</span><span class="p">(</span><span class="n">commit</span><span class="p">,</span> <span class="n">untrustedVs</span><span class="p">),</span> <span class="n">trustedVs</span><span class="p">)</span>

    <span class="c">// check that the signers account for more than max(1/3, trustLevel) of the voting power</span>
    <span class="c">// this ensures that there is at least single correct validator in the set of signers</span>
    <span class="k">if</span> <span class="n">signedPower</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="m">1</span><span class="o">/</span><span class="m">3</span><span class="p">,</span> <span class="n">trustLevel</span><span class="p">)</span> <span class="o">*</span> <span class="n">totalPower</span> <span class="k">return</span> <span class="n">ErrInsufficientVotingPower</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>

<span class="c">// returns nil if commit is signed by more than 2/3 of voting power of the given validator set</span>
<span class="c">// return error otherwise</span>
<span class="k">func</span> <span class="n">verifyCommitFull</span><span class="p">(</span><span class="n">vs</span> <span class="n">ValidatorSet</span><span class="p">,</span> <span class="n">commit</span> <span class="n">Commit</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="n">totalPower</span> <span class="o">:=</span> <span class="n">vs</span><span class="o">.</span><span class="n">TotalVotingPower</span><span class="p">;</span>
    <span class="n">signedPower</span> <span class="o">:=</span> <span class="n">votingPowerIn</span><span class="p">(</span><span class="n">signers</span><span class="p">(</span><span class="n">commit</span><span class="p">,</span> <span class="n">vs</span><span class="p">),</span> <span class="n">vs</span><span class="p">)</span>

    <span class="c">// check the signers account for +2/3 of the voting power</span>
    <span class="k">if</span> <span class="n">signedPower</span> <span class="o">*</span> <span class="m">3</span> <span class="o">&lt;=</span> <span class="n">totalPower</span> <span class="o">*</span> <span class="m">2</span> <span class="k">return</span> <span class="n">ErrInvalidCommit</span>
    <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>VerifyHeaderAtHeight.</strong> The function <code class="language-plaintext highlighter-rouge">VerifyHeaderAtHeight</code> captures high level
logic, i.e., application call to the light client module to download and verify header
for some height.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">VerifyHeaderAtHeight</span><span class="p">(</span><span class="n">untrustedHeight</span> <span class="kt">int64</span><span class="p">,</span>
                          <span class="n">trustedState</span> <span class="n">TrustedState</span><span class="p">,</span>
                          <span class="n">trustThreshold</span> <span class="n">float</span><span class="p">,</span>
                          <span class="n">trustingPeriod</span> <span class="n">Duration</span><span class="p">,</span>
                          <span class="n">clockDrift</span> <span class="n">Duration</span><span class="p">)</span> <span class="p">(</span><span class="n">TrustedState</span><span class="p">,</span> <span class="kt">error</span><span class="p">))</span> <span class="p">{</span>

    <span class="n">trustedHeader</span> <span class="o">:=</span> <span class="n">trustedState</span><span class="o">.</span><span class="n">SignedHeader</span><span class="o">.</span><span class="n">Header</span>

    <span class="n">now</span> <span class="o">:=</span> <span class="n">System</span><span class="o">.</span><span class="n">Time</span><span class="p">()</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">trustedHeader</span><span class="p">,</span> <span class="n">trustingPeriod</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">newTrustedState</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">VerifyBisection</span><span class="p">(</span><span class="n">untrustedHeight</span><span class="p">,</span>
                                            <span class="n">trustedState</span><span class="p">,</span>
                                            <span class="n">trustThreshold</span><span class="p">,</span>
                                            <span class="n">trustingPeriod</span><span class="p">,</span>
                                            <span class="n">clockDrift</span><span class="p">,</span>
                                            <span class="n">now</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>

    <span class="n">now</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="n">Time</span><span class="p">()</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">trustedHeader</span><span class="p">,</span> <span class="n">trustingPeriod</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">newTrustedState</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that in case <code class="language-plaintext highlighter-rouge">VerifyHeaderAtHeight</code> returns without an error (untrusted header
is successfully verified) then we have a guarantee that the transition of the trust
from <code class="language-plaintext highlighter-rouge">trustedState</code> to <code class="language-plaintext highlighter-rouge">newTrustedState</code> happened during the trusted period of
<code class="language-plaintext highlighter-rouge">trustedState.SignedHeader.Header</code>.</p>

<p>In case <code class="language-plaintext highlighter-rouge">VerifyHeaderAtHeight</code> returns with an error, then either (i) the full node we are talking to is faulty
or (ii) the trusted header has expired (it is outside its trusted period). In case (i) the full node is faulty so
light client should disconnect and reinitialize with new peer. In the case (ii) as the trusted header has expired,
we need to reinitialize light client with a new trusted header (that is within its trusted period),
but we don‚Äôt necessarily need to disconnect from the full node we are talking to (as we haven‚Äôt observed full node misbehavior in this case).</p>

<p><strong>VerifyBisection.</strong> The function <code class="language-plaintext highlighter-rouge">VerifyBisection</code> implements
recursive logic for checking if it is possible building trust
relationship between <code class="language-plaintext highlighter-rouge">trustedState</code> and untrusted header at the given height over
finite set of (downloaded and verified) headers.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">VerifyBisection</span><span class="p">(</span><span class="n">untrustedHeight</span> <span class="kt">int64</span><span class="p">,</span>
                     <span class="n">trustedState</span> <span class="n">TrustedState</span><span class="p">,</span>
                     <span class="n">trustThreshold</span> <span class="n">float</span><span class="p">,</span>
                     <span class="n">trustingPeriod</span> <span class="n">Duration</span><span class="p">,</span>
                     <span class="n">clockDrift</span> <span class="n">Duration</span><span class="p">,</span>
                     <span class="n">now</span> <span class="n">Time</span><span class="p">)</span> <span class="p">(</span><span class="n">TrustedState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">untrustedSh</span><span class="p">,</span> <span class="kt">error</span> <span class="o">:=</span> <span class="n">Commit</span><span class="p">(</span><span class="n">untrustedHeight</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrRequestFailed</span><span class="p">)</span>

    <span class="n">untrustedHeader</span> <span class="o">=</span> <span class="n">untrustedSh</span><span class="o">.</span><span class="n">Header</span>

    <span class="c">// note that we pass now during the recursive calls. This is fine as</span>
    <span class="c">// all other untrusted headers we download during recursion will be</span>
    <span class="c">// for a smaller heights, and therefore should happen before.</span>
    <span class="k">if</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Time</span> <span class="o">&gt;</span> <span class="n">now</span> <span class="o">+</span> <span class="n">clockDrift</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrInvalidHeaderTime</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">untrustedVs</span><span class="p">,</span> <span class="kt">error</span> <span class="o">:=</span> <span class="n">Validators</span><span class="p">(</span><span class="n">untrustedHeight</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrRequestFailed</span><span class="p">)</span>

    <span class="n">untrustedNextVs</span><span class="p">,</span> <span class="kt">error</span> <span class="o">:=</span> <span class="n">Validators</span><span class="p">(</span><span class="n">untrustedHeight</span> <span class="o">+</span> <span class="m">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="n">ErrRequestFailed</span><span class="p">)</span>

    <span class="kt">error</span> <span class="o">=</span> <span class="n">verifySingle</span><span class="p">(</span>
             <span class="n">trustedState</span><span class="p">,</span>
             <span class="n">untrustedSh</span><span class="p">,</span>
             <span class="n">untrustedVs</span><span class="p">,</span>
             <span class="n">untrustedNextVs</span><span class="p">,</span>
             <span class="n">trustThreshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fatalError</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="n">trustedState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="k">if</span> <span class="kt">error</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="c">// the untrusted header is now trusted.</span>
        <span class="n">newTrustedState</span> <span class="o">=</span> <span class="n">TrustedState</span><span class="p">(</span><span class="n">untrustedSh</span><span class="p">,</span> <span class="n">untrustedNextVs</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">newTrustedState</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// at this point in time we need to do bisection</span>
    <span class="n">pivotHeight</span> <span class="o">:=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">trustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">+</span> <span class="n">untrustedHeight</span><span class="p">)</span> <span class="o">/</span> <span class="m">2</span><span class="p">)</span>

    <span class="kt">error</span><span class="p">,</span> <span class="n">newTrustedState</span> <span class="o">=</span> <span class="n">VerifyBisection</span><span class="p">(</span><span class="n">pivotHeight</span><span class="p">,</span>
                                             <span class="n">trustedState</span><span class="p">,</span>
                                             <span class="n">trustThreshold</span><span class="p">,</span>
                                             <span class="n">trustingPeriod</span><span class="p">,</span>
                                             <span class="n">clockDrift</span><span class="p">,</span>
                                             <span class="n">now</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="p">(</span><span class="n">newTrustedState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">VerifyBisection</span><span class="p">(</span><span class="n">untrustedHeight</span><span class="p">,</span>
                           <span class="n">newTrustedState</span><span class="p">,</span>
                           <span class="n">trustThreshold</span><span class="p">,</span>
                           <span class="n">trustingPeriod</span><span class="p">,</span>
                           <span class="n">clockDrift</span><span class="p">,</span>
                           <span class="n">now</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">fatalError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span> <span class="o">==</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrInvalidAdjacentHeaders</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrNonIncreasingHeight</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrNonIncreasingTime</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrInvalidValidatorSet</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrInvalidNextValidatorSet</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrInvalidCommitValue</span> <span class="n">OR</span>
           <span class="n">err</span> <span class="o">==</span> <span class="n">ErrInvalidCommit</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="the-case-untrustedheaderheight--trustedheaderheight">The case <code class="language-plaintext highlighter-rouge">untrustedHeader.Height &lt; trustedHeader.Height</code></h3>

<p>In the use case where someone tells the light client that application data that is relevant for it
can be read in the block of height <code class="language-plaintext highlighter-rouge">k</code> and the light client trusts a more recent header, we can use the
hashes to verify headers ‚Äúdown the chain.‚Äù That is, we iterate down the heights and check the hashes in each step.</p>

<p><em>Remark.</em> For the case were the light client trusts two headers <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> with <code class="language-plaintext highlighter-rouge">i &lt; k &lt; j</code>, we should
discuss/experiment whether the forward or the backward method is more effective.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">VerifyHeaderBackwards</span><span class="p">(</span><span class="n">trustedHeader</span> <span class="n">Header</span><span class="p">,</span>
                           <span class="n">untrustedHeader</span> <span class="n">Header</span><span class="p">,</span>
                           <span class="n">trustingPeriod</span> <span class="n">Duration</span><span class="p">,</span>
                           <span class="n">clockDrift</span> <span class="n">Duration</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>

  <span class="k">if</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">&gt;=</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="k">return</span> <span class="n">ErrErrNonDecreasingHeight</span>
  <span class="k">if</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Time</span> <span class="o">&gt;=</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Time</span> <span class="k">return</span> <span class="n">ErrNonDecreasingTime</span>

  <span class="n">now</span> <span class="o">:=</span> <span class="n">System</span><span class="o">.</span><span class="n">Time</span><span class="p">()</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">trustedHeader</span><span class="p">,</span> <span class="n">trustingPeriod</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span>
  <span class="p">}</span>

  <span class="n">old</span> <span class="o">:=</span> <span class="n">trustedHeader</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">trustedHeader</span><span class="o">.</span><span class="n">Height</span> <span class="o">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">untrustedHeader</span><span class="o">.</span><span class="n">Height</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span> <span class="p">{</span>
    <span class="n">untrustedSh</span><span class="p">,</span> <span class="kt">error</span> <span class="o">:=</span> <span class="n">Commit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="kt">error</span> <span class="o">!=</span> <span class="no">nil</span> <span class="k">return</span> <span class="n">ErrRequestFailed</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">untrustedSh</span><span class="o">.</span><span class="n">Header</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old</span><span class="o">.</span><span class="n">LastBlockID</span><span class="o">.</span><span class="n">Hash</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">ErrInvalidAdjacentHeaders</span>
    <span class="p">}</span>

    <span class="n">old</span> <span class="o">:=</span> <span class="n">untrustedSh</span><span class="o">.</span><span class="n">Header</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="n">hash</span><span class="p">(</span><span class="n">untrustedHeader</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old</span><span class="o">.</span><span class="n">LastBlockID</span><span class="o">.</span><span class="n">Hash</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ErrInvalidAdjacentHeaders</span>
  <span class="p">}</span>

  <span class="n">now</span> <span class="o">:=</span> <span class="n">System</span><span class="o">.</span><span class="n">Time</span><span class="p">()</span>
  <span class="k">if</span> <span class="o">!</span><span class="n">isWithinTrustedPeriod</span><span class="p">(</span><span class="n">trustedHeader</span><span class="p">,</span> <span class="n">trustingPeriod</span><span class="p">,</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ErrHeaderNotWithinTrustedPeriod</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="no">nil</span>
 <span class="p">}</span>
</code></pre></div></div>

<p><em>Assumption</em>: In the following, we assume that <em>untrusted_h.Header.height &gt; trusted_h.Header.height</em>. We will quickly discuss the other case in the next section.</p>

<p>We consider the following set-up:</p>

<ul>
  <li>the light client communicates with one full node</li>
  <li>the light client locally stores all the headers that has passed basic verification and that are within light client trust period. In the pseudo code below we
write <em>Store.Add(header)</em> for this. If a header failed to verify, then
the full node we are talking to is faulty and we should disconnect from it and reinitialize with new peer.</li>
  <li>If <code class="language-plaintext highlighter-rouge">CanTrust</code> returns <em>error</em>, then the light client has seen a forged header or the trusted header has expired (it is outside its trusted period).
    <ul>
      <li>In case of forged header, the full node is faulty so light client should disconnect and reinitialize with new peer. If the trusted header has expired,
we need to reinitialize light client with new trusted header (that is within its trusted period), but we don‚Äôt necessarily need to disconnect from the full node
we are talking to (as we haven‚Äôt observed full node misbehavior in this case).</li>
    </ul>
  </li>
</ul>

<h2 id="correctness-of-the-light-client-protocols">Correctness of the Light Client Protocols</h2>

<h3 id="definitions-1">Definitions</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">TRUSTED_PERIOD</code>: trusted period</li>
  <li>for realtime <code class="language-plaintext highlighter-rouge">t</code>, the predicate <code class="language-plaintext highlighter-rouge">correct(v,t)</code> is true if the validator <code class="language-plaintext highlighter-rouge">v</code>
follows the protocol until time <code class="language-plaintext highlighter-rouge">t</code> (we will see about recovery later).</li>
  <li>Validator fields. We will write a validator as a tuple <code class="language-plaintext highlighter-rouge">(v,p)</code> such that
    <ul>
      <li><code class="language-plaintext highlighter-rouge">v</code> is the identifier (i.e., validator address; we assume identifiers are unique in each validator set)</li>
      <li><code class="language-plaintext highlighter-rouge">p</code> is its voting power</li>
    </ul>
  </li>
  <li>For each header <code class="language-plaintext highlighter-rouge">h</code>, we write <code class="language-plaintext highlighter-rouge">trust(h) = true</code> if the light client trusts <code class="language-plaintext highlighter-rouge">h</code>.</li>
</ul>

<h3 id="failure-model-1">Failure Model</h3>

<p>If a block <code class="language-plaintext highlighter-rouge">b</code> with a header <code class="language-plaintext highlighter-rouge">h</code> is generated at time <code class="language-plaintext highlighter-rouge">Time</code> (i.e. <code class="language-plaintext highlighter-rouge">h.Time = Time</code>), then a set of validators that
hold more than <code class="language-plaintext highlighter-rouge">2/3</code> of the voting power in <code class="language-plaintext highlighter-rouge">validators(h.NextValidatorsHash)</code> is correct until time
<code class="language-plaintext highlighter-rouge">h.Time + TRUSTED_PERIOD</code>.</p>

<p>Formally,
[
\sum_{(v,p) \in validators(h.NextValidatorsHash) \wedge correct(v,h.Time + TRUSTED_PERIOD)} p &gt;
2/3 \sum_{(v,p) \in validators(h.NextValidatorsHash)} p
]</p>

<p>The light client communicates with a full node and learns new headers. The goal is to locally decide whether to trust a header. Our implementation needs to ensure the following two properties:</p>

<ul>
  <li>
    <p><em>Light Client Completeness</em>: If a header <code class="language-plaintext highlighter-rouge">h</code> was correctly generated by an instance of Tendermint consensus (and its age is less than the trusted period),
then the light client should eventually set <code class="language-plaintext highlighter-rouge">trust(h)</code> to <code class="language-plaintext highlighter-rouge">true</code>.</p>
  </li>
  <li>
    <p><em>Light Client Accuracy</em>: If a header <code class="language-plaintext highlighter-rouge">h</code> was <em>not generated</em> by an instance of Tendermint consensus, then the light client should never set <code class="language-plaintext highlighter-rouge">trust(h)</code> to true.</p>
  </li>
</ul>

<p><em>Remark</em>: If in the course of the computation, the light client obtains certainty that some headers were forged by adversaries
(that is were not generated by an instance of Tendermint consensus), it may submit (a subset of) the headers it has seen as evidence of misbehavior.</p>

<p><em>Remark</em>: In Completeness we use ‚Äúeventually‚Äù, while in practice <code class="language-plaintext highlighter-rouge">trust(h)</code> should be set to true before <code class="language-plaintext highlighter-rouge">h.Time + TRUSTED_PERIOD</code>. If not, the header
cannot be trusted because it is too old.</p>

<p><em>Remark</em>: If a header <code class="language-plaintext highlighter-rouge">h</code> is marked with <code class="language-plaintext highlighter-rouge">trust(h)</code>, but it is too old at some point in time we denote with <code class="language-plaintext highlighter-rouge">now</code> (<code class="language-plaintext highlighter-rouge">h.Time + TRUSTED_PERIOD &lt; now</code>),
then the light client should set <code class="language-plaintext highlighter-rouge">trust(h)</code> to <code class="language-plaintext highlighter-rouge">false</code> again at time <code class="language-plaintext highlighter-rouge">now</code>.</p>

<p><em>Assumption</em>: Initially, the light client has a header <code class="language-plaintext highlighter-rouge">inithead</code> that it trusts, that is, <code class="language-plaintext highlighter-rouge">inithead</code> was correctly generated by the Tendermint consensus.</p>

<p>To reason about the correctness, we may prove the following invariant.</p>

<p><em>Verification Condition: light Client Invariant.</em>
 For each light client <code class="language-plaintext highlighter-rouge">l</code> and each header <code class="language-plaintext highlighter-rouge">h</code>:
if <code class="language-plaintext highlighter-rouge">l</code> has set <code class="language-plaintext highlighter-rouge">trust(h) = true</code>,
  then validators that are correct until time <code class="language-plaintext highlighter-rouge">h.Time + TRUSTED_PERIOD</code> have more than two thirds of the voting power in <code class="language-plaintext highlighter-rouge">validators(h.NextValidatorsHash)</code>.</p>

<p>Formally,
  [
  \sum_{(v,p) \in validators(h.NextValidatorsHash) \wedge correct(v,h.Time + TRUSTED_PERIOD)} p &gt;
  2/3 \sum_{(v,p) \in validators(h.NextValidatorsHash)} p
  ]</p>

<p><em>Remark.</em> To prove the invariant, we will have to prove that the light client only trusts headers that were correctly generated by Tendermint consensus.
Then the formula above follows from the failure model.</p>

<h2 id="details">Details</h2>

<p><strong>Observation 1.</strong> If <code class="language-plaintext highlighter-rouge">h.Time + TRUSTED_PERIOD &gt; now</code>, we trust the validator set <code class="language-plaintext highlighter-rouge">validators(h.NextValidatorsHash)</code>.</p>

<p>When we say we trust <code class="language-plaintext highlighter-rouge">validators(h.NextValidatorsHash)</code> we do <code class="language-plaintext highlighter-rouge">not</code> trust that each individual validator in <code class="language-plaintext highlighter-rouge">validators(h.NextValidatorsHash)</code>
is correct, but we only trust the fact that less than <code class="language-plaintext highlighter-rouge">1/3</code> of them are faulty (more precisely, the faulty ones have less than <code class="language-plaintext highlighter-rouge">1/3</code> of the total voting power).</p>

<p><em><code class="language-plaintext highlighter-rouge">VerifySingle</code> correctness arguments</em></p>

<p>Light Client Accuracy:</p>

<ul>
  <li>Assume by contradiction that <code class="language-plaintext highlighter-rouge">untrustedHeader</code> was not generated correctly and the light client sets trust to true because <code class="language-plaintext highlighter-rouge">verifySingle</code> returns without error.</li>
  <li><code class="language-plaintext highlighter-rouge">trustedState</code> is trusted and sufficiently new</li>
  <li>by the Failure Model, less than <code class="language-plaintext highlighter-rouge">1/3</code> of the voting power held by faulty validators =&gt; at least one correct validator <code class="language-plaintext highlighter-rouge">v</code> has signed <code class="language-plaintext highlighter-rouge">untrustedHeader</code>.</li>
  <li>as <code class="language-plaintext highlighter-rouge">v</code> is correct up to now, it followed the Tendermint consensus protocol at least up to signing <code class="language-plaintext highlighter-rouge">untrustedHeader</code> =&gt; <code class="language-plaintext highlighter-rouge">untrustedHeader</code> was correctly generated.
We arrive at the required contradiction.</li>
</ul>

<p>Light Client Completeness:</p>

<ul>
  <li>The check is successful if sufficiently many validators of <code class="language-plaintext highlighter-rouge">trustedState</code> are still validators in the height <code class="language-plaintext highlighter-rouge">untrustedHeader.Height</code> and signed <code class="language-plaintext highlighter-rouge">untrustedHeader</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">untrustedHeader.Height = trustedHeader.Height + 1</code>, and both headers were generated correctly, the test passes.</li>
</ul>

<p><em>Verification Condition:</em> We may need an invariant stating that if <code class="language-plaintext highlighter-rouge">untrustedSignedHeader.Header.Height = trustedHeader.Height + 1</code> then
<code class="language-plaintext highlighter-rouge">signers(untrustedSignedHeader.Commit) \subseteq validators(trustedHeader.NextValidatorsHash)</code>.</p>

<p><em>Remark</em>: The variable <code class="language-plaintext highlighter-rouge">trustThreshold</code> can be used if the user believes that relying on one correct validator is not sufficient.
However, in case of (frequent) changes in the validator set, the higher the <code class="language-plaintext highlighter-rouge">trustThreshold</code> is chosen, the more unlikely it becomes that
<code class="language-plaintext highlighter-rouge">verifySingle</code> returns with an error for non-adjacent headers.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">VerifyBisection</code> correctness arguments (sketch)*</li>
</ul>

<p>Light Client Accuracy:</p>

<ul>
  <li>Assume by contradiction that the header at <code class="language-plaintext highlighter-rouge">untrustedHeight</code> obtained from the full node was not generated correctly and
the light client sets trust to true because <code class="language-plaintext highlighter-rouge">VerifyBisection</code> returns without an error.</li>
  <li><code class="language-plaintext highlighter-rouge">VerifyBisection</code> returns without error only if all calls to <code class="language-plaintext highlighter-rouge">verifySingle</code> in the recursion return without error (return <code class="language-plaintext highlighter-rouge">nil</code>).</li>
  <li>Thus we have a sequence of headers that all satisfied the <code class="language-plaintext highlighter-rouge">verifySingle</code></li>
  <li>again a contradiction</li>
</ul>

<p>light Client Completeness:</p>

<p>This is only ensured if upon <code class="language-plaintext highlighter-rouge">Commit(pivot)</code> the light client is always provided with a correctly generated header.</p>

<p><em>Stalling</em></p>

<p>With <code class="language-plaintext highlighter-rouge">VerifyBisection</code>, a faulty full node could stall a light client by creating a long sequence of headers that are queried one-by-one by the light client and look OK,
before the light client eventually detects a problem. There are several ways to address this:</p>

<ul>
  <li>Each call to <code class="language-plaintext highlighter-rouge">Commit</code> could be issued to a different full node</li>
  <li>Instead of querying header by header, the light client tells a full node which header it trusts, and the height of the header it needs. The full node responds with
the header along with a proof consisting of intermediate headers that the light client can use to verify. Roughly, <code class="language-plaintext highlighter-rouge">VerifyBisection</code> would then be executed at the full node.</li>
  <li>We may set a timeout how long <code class="language-plaintext highlighter-rouge">VerifyBisection</code> may take.</li>
</ul>
:ET