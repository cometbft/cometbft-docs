I"zD<h1 id="cometbfts-expected-behavior">CometBFT’s expected behavior</h1>

<h2 id="valid-method-call-sequences">Valid method call sequences</h2>

<p>This section describes what the Application can expect from CometBFT.</p>

<p>The Tendermint consensus algorithm, currently adopted in CometBFT, is designed to protect safety under any network conditions, as long as
less than 1/3 of validators’ voting power is byzantine. Most of the time, though, the network will behave
synchronously, no process will fall behind, and there will be no byzantine process. The following describes
what will happen during a block height <em>h</em> in these frequent, benign conditions:</p>

<ul>
  <li>Tendermint will decide in round 0, for height <em>h</em>;</li>
  <li><code class="language-plaintext highlighter-rouge">PrepareProposal</code> will be called exactly once at the proposer process of round 0, height <em>h</em>;</li>
  <li><code class="language-plaintext highlighter-rouge">ProcessProposal</code> will be called exactly once at all processes, and
will return <em>accept</em> in its <code class="language-plaintext highlighter-rouge">Response*</code>;
&lt;!–</li>
  <li><code class="language-plaintext highlighter-rouge">ExtendVote</code> will be called exactly once at all processes;</li>
  <li><code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> will be called exactly <em>n-1</em> times at each validator process, where <em>n</em> is
the number of validators, and will always return <em>accept</em> in its <code class="language-plaintext highlighter-rouge">Response*</code>; 
–&gt;</li>
  <li><code class="language-plaintext highlighter-rouge">BeginBlock</code> will be called exactly once at all processes, conveying the same prepared
block header that all calls to <code class="language-plaintext highlighter-rouge">PrepareProposal</code> and <code class="language-plaintext highlighter-rouge">ProcessProposal</code> had previously reported for
height <em>h</em>; and</li>
  <li><code class="language-plaintext highlighter-rouge">DeliverTx</code> will be called exactly once for each transaction within the block.</li>
  <li><code class="language-plaintext highlighter-rouge">EndBlock</code> will be called exactly once after <code class="language-plaintext highlighter-rouge">DeliverTx</code> has been executed for all transactions and marks
the end of processing for the block.</li>
  <li><code class="language-plaintext highlighter-rouge">Commit</code> will finally be called exactly once at all processes at the end of height <em>h</em>.</li>
</ul>

<p>However, the Application logic must be ready to cope with any possible run of Tendermint for a given
height, including bad periods (byzantine proposers, network being asynchronous).
In these cases, the sequence of calls to ABCI++ methods may not be so straighforward, but
the Application should still be able to handle them, e.g., without crashing.
The purpose of this section is to define what these sequences look like in a precise way.</p>

<p>As mentioned in the <a href="./abci%2B%2B_basic_concepts.md">Basic Concepts</a> section, CometBFT
acts as a client of ABCI++ and the Application acts as a server. Thus, it is up to CometBFT to
determine when and in which order the different ABCI++ methods will be called. A well-written
Application design should consider <em>any</em> of these possible sequences.</p>

<p>The following grammar, written in case-sensitive Augmented Backus–Naur form (ABNF, specified
in <a href="https://datatracker.ietf.org/doc/html/rfc7405">IETF rfc7405</a>), specifies all possible
sequences of calls to ABCI++, taken by a correct process, across all heights from the genesis block,
including recovery runs, from the point of view of the Application.</p>

<pre><code class="language-abnf">start               = clean-start / recovery

clean-start         = init-chain [state-sync] consensus-exec
state-sync          = *state-sync-attempt success-sync info
state-sync-attempt  = offer-snapshot *apply-chunk
success-sync        = offer-snapshot 1*apply-chunk

recovery            = info consensus-exec

consensus-exec      = (inf)consensus-height
consensus-height    = *consensus-round decide commit
consensus-round     = proposer / non-proposer

proposer            =  prepare-proposal process-proposal
non-proposer        = [process-proposal]
decide              = begin-block  *deliver-txs end-block

init-chain          = %s"&lt;InitChain&gt;"
offer-snapshot      = %s"&lt;OfferSnapshot&gt;"
apply-chunk         = %s"&lt;ApplySnapshotChunk&gt;"
info                = %s"&lt;Info&gt;"
prepare-proposal    = %s"&lt;PrepareProposal&gt;"
process-proposal    = %s"&lt;ProcessProposal&gt;"
begin-block         = %s"&lt;BeginBlock&gt;"
deliver-txs         = %s"&lt;DeliverTx&gt;"
end-block           = %s"&lt;EndBlock&gt;"
commit              = %s"&lt;Commit&gt;"
</code></pre>
<!-- 
extend-vote         = %s"<ExtendVote>"
got-vote            = %s"<VerifyVoteExtension>"
decide              = %s"<FinalizeBlock>" 
-->
<p>We have kept some ABCI methods out of the grammar, in order to keep it as clear and concise as possible.
A common reason for keeping all these methods out is that they all can be called at any point in a sequence defined
by the grammar above. Other reasons depend on the method in question:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Echo</code> and <code class="language-plaintext highlighter-rouge">Flush</code> are only used for debugging purposes. Further, their handling by the Application should be trivial.</li>
  <li><code class="language-plaintext highlighter-rouge">CheckTx</code> is detached from the main method call sequence that drives block execution.</li>
  <li><code class="language-plaintext highlighter-rouge">Query</code> provides read-only access to the current Application state, so handling it should also be independent from
block execution.</li>
  <li>Similarly, <code class="language-plaintext highlighter-rouge">ListSnapshots</code> and <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code> provide read-only access to the Application’s previously created
snapshots (if any), and help populate the parameters of <code class="language-plaintext highlighter-rouge">OfferSnapshot</code> and <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> at a process performing
state-sync while bootstrapping. Unlike <code class="language-plaintext highlighter-rouge">ListSnapshots</code> and <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code>, both <code class="language-plaintext highlighter-rouge">OfferSnapshot</code>
and <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> <em>are</em> included in the grammar.</li>
</ul>

<p>Finally, method <code class="language-plaintext highlighter-rouge">Info</code> is a special case. The method’s purpose is three-fold, it can be used</p>

<ol>
  <li>as part of handling an RPC call from an external client,</li>
  <li>as a handshake between CometBFT and the Application upon recovery to check whether any blocks need
to be replayed, and</li>
  <li>at the end of <em>state-sync</em> to verify that the correct state has been reached.</li>
</ol>

<p>We have left <code class="language-plaintext highlighter-rouge">Info</code>’s first purpose out of the grammar for the same reasons as all the others: it can happen
at any time, and has nothing to do with the block execution sequence. The second and third purposes, on the other
hand, are present in the grammar.</p>

<p>Let us now examine the grammar line by line, providing further details.</p>

<ul>
  <li>When a process starts, it may do so for the first time or after a crash (it is recovering).</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">start               = clean-start / recovery
</code></pre>
</blockquote>

<ul>
  <li>If the process is starting from scratch, CometBFT first calls <code class="language-plaintext highlighter-rouge">InitChain</code>, then it may optionally
start a <em>state-sync</em> mechanism to catch up with other processes. Finally, it enters normal
consensus execution.</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">clean-start         = init-chain [state-sync] consensus-exec
</code></pre>
</blockquote>

<ul>
  <li>In <em>state-sync</em> mode, CometBFT makes one or more attempts at synchronizing the Application’s state.
At the beginning of each attempt, it offers the Application a snapshot found at another process.
If the Application accepts the snapshot, a sequence of calls to <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> method follow
to provide the Application with all the snapshots needed, in order to reconstruct the state locally.
A successful attempt must provide at least one chunk via <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code>.
At the end of a successful attempt, CometBFT calls <code class="language-plaintext highlighter-rouge">Info</code> to make sure the recontructed state’s
<em>AppHash</em> matches the one in the block header at the corresponding height.</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">state-sync          = *state-sync-attempt success-sync info
state-sync-attempt  = offer-snapshot *apply-chunk
success-sync        = offer-snapshot 1*apply-chunk
</code></pre>
</blockquote>

<ul>
  <li>In recovery mode, CometBFT first calls <code class="language-plaintext highlighter-rouge">Info</code> to know from which height it needs to replay decisions
to the Application. After this, CometBFT enters nomal consensus execution.</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">recovery            = info consensus-exec
</code></pre>
</blockquote>

<ul>
  <li>The non-terminal <code class="language-plaintext highlighter-rouge">consensus-exec</code> is a key point in this grammar. It is an infinite sequence of
consensus heights. The grammar is thus an
<a href="https://dl.acm.org/doi/10.5555/2361476.2361481">omega-grammar</a>, since it produces infinite
sequences of terminals (i.e., the API calls).</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">consensus-exec      = (inf)consensus-height
</code></pre>
</blockquote>

<ul>
  <li>A consensus height consists of zero or more rounds before deciding and executing via a call to
<code class="language-plaintext highlighter-rouge">BeginBlock-DeliverTx-EndBlock</code>, followed by a call to <code class="language-plaintext highlighter-rouge">Commit</code>. In each round, the sequence of method calls
depends on whether the local process is the proposer or not. Note that, if a height contains zero
rounds, this means the process is replaying an already decided value (catch-up mode).</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">consensus-height    = *consensus-round decide commit
consensus-round     = proposer / non-proposer
</code></pre>
</blockquote>

<ul>
  <li>
    <p>For every round, if the local process is the proposer of the current round, CometBFT starts by
calling <code class="language-plaintext highlighter-rouge">PrepareProposal</code>, followed by <code class="language-plaintext highlighter-rouge">ProcessProposal</code>.
&lt;!–</p>

    <p>Then, optionally, the Application is
asked to extend its vote for that round. Calls to <code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> can come at any time: the
local process may be slightly late in the current round, or votes may come from a future round
of this height. 
–&gt;</p>
  </li>
</ul>

<blockquote>
  <pre><code class="language-abnf">proposer            = prepare-proposal process-proposal 
</code></pre>
</blockquote>

<ul>
  <li>
    <p>Also for every round, if the local process is <em>not</em> the proposer of the current round, CometBFT
will call <code class="language-plaintext highlighter-rouge">ProcessProposal</code> at most once.
&lt;!–</p>

    <p>At most one call to <code class="language-plaintext highlighter-rouge">ExtendVote</code> may occur only after
<code class="language-plaintext highlighter-rouge">ProcessProposal</code> is called. A number of calls to <code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> can occur in any order
with respect to <code class="language-plaintext highlighter-rouge">ProcessProposal</code> and <code class="language-plaintext highlighter-rouge">ExtendVote</code> throughout the round. The reasons are the same
as above, namely, the process running slightly late in the current round, or votes from future
rounds of this height received. 
–&gt;</p>
  </li>
</ul>

<blockquote>
  <pre><code class="language-abnf">non-proposer        = [process-proposal]
</code></pre>
</blockquote>

<ul>
  <li>Finally, the grammar describes all its terminal symbols, which denote the different ABCI++ method calls that
may appear in a sequence.</li>
</ul>

<blockquote>
  <pre><code class="language-abnf">init-chain          = %s"&lt;InitChain&gt;"
offer-snapshot      = %s"&lt;OfferSnapshot&gt;"
apply-chunk         = %s"&lt;ApplySnapshotChunk&gt;"
info                = %s"&lt;Info&gt;"
prepare-proposal    = %s"&lt;PrepareProposal&gt;"
process-proposal    = %s"&lt;ProcessProposal&gt;"
begin-block         = %s"&lt;BeginBlock&gt;" 
deliver-txs         = %s"&lt;DeliverTx&gt;"
end-block           = %s"&lt;EndBlock&gt;"
commit              = %s"&lt;Commit&gt;"
</code></pre>
</blockquote>

<h2 id="adapting-existing-applications-that-use-abci">Adapting existing Applications that use ABCI</h2>

<p>In some cases, an existing Application using the legacy ABCI may need to be adapted to work with ABCI++
with as minimal changes as possible. In this case, of course, ABCI++ will not provide any advange with respect
to the existing implementation, but will keep the same guarantees already provided by ABCI.
Here is how ABCI++ methods should be implemented.</p>

<p>First of all, all the methods that did not change from ABCI to ABCI++, namely <code class="language-plaintext highlighter-rouge">Echo</code>, <code class="language-plaintext highlighter-rouge">Flush</code>, <code class="language-plaintext highlighter-rouge">Info</code>, <code class="language-plaintext highlighter-rouge">InitChain</code>,
<code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">DerliverTx</code>, <code class="language-plaintext highlighter-rouge">EndBlock</code>, <code class="language-plaintext highlighter-rouge">Commit</code>, <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">CheckTx</code>, <code class="language-plaintext highlighter-rouge">ListSnapshots</code>, <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code>, <code class="language-plaintext highlighter-rouge">OfferSnapshot</code>,
and <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code>, do not need to undergo any changes in their implementation.</p>

<p>As for the new methods:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">PrepareProposal</code> must create a list of <a href="/v0.37/spec/abci/abci++_methods/#prepareproposal">transactions</a>
by copying over the transaction list passed in <code class="language-plaintext highlighter-rouge">RequestPrepareProposal.txs</code>, in the same order.</p>

    <p>The Application must check whether the size of all transactions exceeds the byte limit
(<code class="language-plaintext highlighter-rouge">RequestPrepareProposal.max_tx_bytes</code>). If so, the Application must remove transactions at the
end of the list until the total byte size is at or below the limit.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ProcessProposal</code> must set <code class="language-plaintext highlighter-rouge">ResponseProcessProposal.status</code> to <em>accept</em> and return.
&lt;!–</li>
  <li><code class="language-plaintext highlighter-rouge">ExtendVote</code> is to set <code class="language-plaintext highlighter-rouge">ResponseExtendVote.extension</code> to an empty byte array and return.</li>
  <li><code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> must set <code class="language-plaintext highlighter-rouge">ResponseVerifyVoteExtension.accept</code> to <em>true</em> if the extension is
an empty byte array and <em>false</em> otherwise, then return.
 –&gt;
&lt;!–</li>
  <li><code class="language-plaintext highlighter-rouge">FinalizeBlock</code> is to coalesce the implementation of methods <code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">DeliverTx</code>, and
<code class="language-plaintext highlighter-rouge">EndBlock</code>. Legacy applications looking to reuse old code that implemented <code class="language-plaintext highlighter-rouge">DeliverTx</code> should
wrap the legacy <code class="language-plaintext highlighter-rouge">DeliverTx</code> logic in a loop that executes one transaction iteration per
transaction in <code class="language-plaintext highlighter-rouge">RequestFinalizeBlock.tx</code>. 
–&gt;</li>
</ul>

<!--
Finally, `Commit`, which is kept in ABCI++, no longer returns the `AppHash`. It is now up to
`FinalizeBlock` to do so. Thus, a slight refactoring of the old `Commit` implementation will be
needed to move the return of `AppHash` to `FinalizeBlock`.
 -->
:ET