I"í <h1 id="requirements-for-the-application">Requirements for the Application</h1>

<h2 id="formal-requirements">Formal Requirements</h2>

<p>This section specifies what CometBFT expects from the Application. It is structured as a set
of formal requirements that can be used for testing and verification of the Application‚Äôs logic.</p>

<p>Let <em>p</em> and <em>q</em> be two correct processes.
Let <em>r<sub>p</sub></em> (resp. <em>r<sub>q</sub></em>) be a round of height <em>h</em> where <em>p</em> (resp. <em>q</em>) is the
proposer.
Let <em>s<sub>p,h-1</sub></em> be <em>p</em>‚Äôs Application‚Äôs state committed for height <em>h-1</em>.
Let <em>v<sub>p</sub></em> (resp. <em>v<sub>q</sub></em>) be the block that <em>p</em>‚Äôs (resp. <em>q</em>‚Äôs) CometBFT passes
on to the Application
via <code class="language-plaintext highlighter-rouge">RequestPrepareProposal</code> as proposer of round <em>r<sub>p</sub></em> (resp <em>r<sub>q</sub></em>), height <em>h</em>,
also known as the raw proposal.
Let <em>u<sub>p</sub></em> (resp. <em>u<sub>q</sub></em>) the possibly modified block <em>p</em>‚Äôs (resp. <em>q</em>‚Äôs) Application
returns via <code class="language-plaintext highlighter-rouge">ResponsePrepareProposal</code> to CometBFT, also known as the prepared proposal.</p>

<p>Process <em>p</em>‚Äôs prepared proposal can differ in two different rounds where <em>p</em> is the proposer.</p>

<ul>
  <li>Requirement 1 [<code class="language-plaintext highlighter-rouge">PrepareProposal</code>, timeliness]: If <em>p</em>‚Äôs Application fully executes prepared blocks in
<code class="language-plaintext highlighter-rouge">PrepareProposal</code> and the network is in a synchronous period while processes <em>p</em> and <em>q</em> are in <em>r<sub>p</sub></em>,
then the value of <em>TimeoutPropose</em> at <em>q</em> must be such that <em>q</em>‚Äôs propose timer does not time out
(which would result in <em>q</em> prevoting <code class="language-plaintext highlighter-rouge">nil</code> in <em>r<sub>p</sub></em>).</li>
</ul>

<p>Full execution of blocks at <code class="language-plaintext highlighter-rouge">PrepareProposal</code> time stands on CometBFT‚Äôs critical path. Thus,
Requirement 1 ensures the Application or operator will set a value for <code class="language-plaintext highlighter-rouge">TimeoutPropose</code> such that the time it takes
to fully execute blocks in <code class="language-plaintext highlighter-rouge">PrepareProposal</code> does not interfere with CometBFT‚Äôs propose timer.
Note that violation of Requirement 1 may just lead to further rounds, but will not compromise liveness.</p>

<ul>
  <li>Requirement 2 [<code class="language-plaintext highlighter-rouge">PrepareProposal</code>, tx-size]: When <em>p</em>‚Äôs Application calls <code class="language-plaintext highlighter-rouge">ResponsePrepareProposal</code>, the
total size in bytes of the transactions returned does not exceed <code class="language-plaintext highlighter-rouge">RequestPrepareProposal.max_tx_bytes</code>.</li>
</ul>

<p>Busy blockchains might seek to maximize the amount of transactions included in each block. Under those conditions,
CometBFT might choose to increase the transactions passed to the Application via <code class="language-plaintext highlighter-rouge">RequestPrepareProposal.txs</code>
beyond the <code class="language-plaintext highlighter-rouge">RequestPrepareProposal.max_tx_bytes</code> limit. The idea is that, if the Application drops some of
those transactions, it can still return a transaction list whose byte size is as close to
<code class="language-plaintext highlighter-rouge">RequestPrepareProposal.max_tx_bytes</code> as possible. Thus, Requirement 2 ensures that the size in bytes of the
transaction list returned by the application will never cause the resulting block to go beyond its byte size
limit.</p>

<ul>
  <li>Requirement 3 [<code class="language-plaintext highlighter-rouge">PrepareProposal</code>, <code class="language-plaintext highlighter-rouge">ProcessProposal</code>, coherence]: For any two correct processes <em>p</em> and <em>q</em>,
if <em>q</em>‚Äôs CometBFT calls <code class="language-plaintext highlighter-rouge">RequestProcessProposal</code> on <em>u<sub>p</sub></em>,
<em>q</em>‚Äôs Application returns Accept in <code class="language-plaintext highlighter-rouge">ResponseProcessProposal</code>.</li>
</ul>

<p>Requirement 3 makes sure that blocks proposed by correct processes <em>always</em> pass the correct receiving process‚Äôs
<code class="language-plaintext highlighter-rouge">ProcessProposal</code> check.
On the other hand, if there is a deterministic bug in <code class="language-plaintext highlighter-rouge">PrepareProposal</code> or <code class="language-plaintext highlighter-rouge">ProcessProposal</code> (or in both),
strictly speaking, this makes all processes that hit the bug byzantine. This is a problem in practice,
as very often validators are running the Application from the same codebase, so potentially <em>all</em> would
likely hit the bug at the same time. This would result in most (or all) processes prevoting <code class="language-plaintext highlighter-rouge">nil</code>, with the
serious consequences on CometBFT‚Äôs liveness that this entails. Due to its criticality, Requirement 3 is a
target for extensive testing and automated verification.</p>

<ul>
  <li>
    <p>Requirement 4 [<code class="language-plaintext highlighter-rouge">ProcessProposal</code>, determinism-1]: <code class="language-plaintext highlighter-rouge">ProcessProposal</code> is a (deterministic) function of the current
state and the block that is about to be applied. In other words, for any correct process <em>p</em>, and any arbitrary block <em>u</em>,
if <em>p</em>‚Äôs CometBFT calls <code class="language-plaintext highlighter-rouge">RequestProcessProposal</code> on <em>u</em> at height <em>h</em>,
then <em>p</em>‚Äôs Application‚Äôs acceptance or rejection <strong>exclusively</strong> depends on <em>u</em> and <em>s<sub>p,h-1</sub></em>.</p>
  </li>
  <li>
    <p>Requirement 5 [<code class="language-plaintext highlighter-rouge">ProcessProposal</code>, determinism-2]: For any two correct processes <em>p</em> and <em>q</em>, and any arbitrary
block <em>u</em>,
if <em>p</em>‚Äôs (resp. <em>q</em>‚Äôs) CometBFT calls <code class="language-plaintext highlighter-rouge">RequestProcessProposal</code> on <em>u</em> at height <em>h</em>,
then <em>p</em>‚Äôs Application accepts <em>u</em> if and only if <em>q</em>‚Äôs Application accepts <em>u</em>.
Note that this requirement follows from Requirement 4 and the Agreement property of consensus.</p>
  </li>
</ul>

<p>Requirements 4 and 5 ensure that all correct processes will react in the same way to a proposed block, even
if the proposer is Byzantine. However, <code class="language-plaintext highlighter-rouge">ProcessProposal</code> may contain a bug that renders the
acceptance or rejection of the block non-deterministic, and therefore prevents processes hitting
the bug from fulfilling Requirements 4 or 5 (effectively making those processes Byzantine).
In such a scenario, CometBFT‚Äôs liveness cannot be guaranteed.
Again, this is a problem in practice if most validators are running the same software, as they are likely
to hit the bug at the same point. There is currently no clear solution to help with this situation, so
the Application designers/implementors must proceed very carefully with the logic/implementation
of <code class="language-plaintext highlighter-rouge">ProcessProposal</code>. As a general rule <code class="language-plaintext highlighter-rouge">ProcessProposal</code> SHOULD always accept the block.</p>

<p>According to the Tendermint consensus algorithm, currently adopted in CometBFT,
a correct process can broadcast at most one precommit
message in round <em>r</em>, height <em>h</em>.</p>

<!-- 
Since, as stated in the [Methods](/main/spec/abci/abci++_methods/#extendvote) section, `ResponseExtendVote`
is only called when the consensus algorithm
is about to broadcast a non-`nil` precommit message, a correct process can only produce one vote extension
in round *r*, height *h*.
Let *e<sup>r</sup><sub>p</sub>* be the vote extension that the Application of a correct process *p* returns via
`ResponseExtendVote` in round *r*, height *h*.
Let *w<sup>r</sup><sub>p</sub>* be the proposed block that *p*'s CometBFT passes to the Application via `RequestExtendVote`
in round *r*, height *h*. 
-->

<!--
* Requirement 6 [`ExtendVote`, `VerifyVoteExtension`, coherence]: For any two different correct
  processes *p* and *q*, if *q* receives *e<sup>r</sup><sub>p</sub>* from *p* in height *h*, *q*'s
  Application returns Accept in `ResponseVerifyVoteExtension`.

Requirement 6 constrains the creation and handling of vote extensions in a similar way as Requirement 3
constrains the creation and handling of proposed blocks.
Requirement 6 ensures that extensions created by correct processes *always* pass the `VerifyVoteExtension`
checks performed by correct processes receiving those extensions.
However, if there is a (deterministic) bug in `ExtendVote` or `VerifyVoteExtension` (or in both),
we will face the same liveness issues as described for Requirement 5, as Precommit messages with invalid vote
extensions will be discarded.

* Requirement 7 [`VerifyVoteExtension`, determinism-1]: `VerifyVoteExtension` is a (deterministic) function of
  the current state, the vote extension received, and the prepared proposal that the extension refers to.
  In other words, for any correct process *p*, and any arbitrary vote extension *e*, and any arbitrary
  block *w*, if *p*'s (resp. *q*'s) CometBFT calls `RequestVerifyVoteExtension` on *e* and *w* at height *h*,
  then *p*'s Application's acceptance or rejection **exclusively** depends on *e*, *w* and *s<sub>p,h-1</sub>*.

* Requirement 8 [`VerifyVoteExtension`, determinism-2]: For any two correct processes *p* and *q*,
  and any arbitrary vote extension *e*, and any arbitrary block *w*,
  if *p*'s (resp. *q*'s) CometBFT calls `RequestVerifyVoteExtension` on *e* and *w* at height *h*,
  then *p*'s Application accepts *e* if and only if *q*'s Application accepts *e*.
  Note that this requirement follows from Requirement 7 and the Agreement property of consensus.

Requirements 7 and 8 ensure that the validation of vote extensions will be deterministic at all
correct processes.
Requirements 7 and 8 protect against arbitrary vote extension data from Byzantine processes,
in a similar way as Requirements 4 and 5 protect against arbitrary proposed blocks.
Requirements 7 and 8 can be violated by a bug inducing non-determinism in
`VerifyVoteExtension`. In this case liveness can be compromised.
Extra care should be put in the implementation of `ExtendVote` and `VerifyVoteExtension`.
As a general rule, `VerifyVoteExtension` SHOULD always accept the vote extension.

-->
<ul>
  <li>
    <p>Requirement 9 [<em>all</em>, no-side-effects]: <em>p</em>‚Äôs calls to <code class="language-plaintext highlighter-rouge">RequestPrepareProposal</code>,
<code class="language-plaintext highlighter-rouge">RequestProcessProposal</code>,
&lt;!‚Äì</p>

    <p><code class="language-plaintext highlighter-rouge">RequestExtendVote</code>, and <code class="language-plaintext highlighter-rouge">RequestVerifyVoteExtension</code> 
‚Äì&gt;
at height <em>h</em> do
not modify <em>s<sub>p,h-1</sub></em>.</p>
  </li>
</ul>

<!-- 
* Requirement 10 [`ExtendVote`, `FinalizeBlock`, non-dependency]: for any correct process *p*,
and any vote extension *e* that *p* received at height *h*, the computation of
*s<sub>p,h</sub>* does not depend on *e*.
-->
<p>The call to correct process <em>p</em>‚Äôs <code class="language-plaintext highlighter-rouge">BeginBlock - DeliverTx - EndBlock</code> sequence at height <em>h</em>, with block <em>v<sub>p,h</sub></em>
passed as parameter, creates state <em>s<sub>p,h</sub></em>.
Additionally, <em>p</em>‚Äôs <code class="language-plaintext highlighter-rouge">DeliverTx</code> on transactions creates a set of transaction results <em>T<sub>p,h</sub></em>.</p>

<ul>
  <li>
    <p>Requirement 11 [<code class="language-plaintext highlighter-rouge">BeginBlock - DeliverTx - EndBlock</code>, determinism-1]: For any correct process <em>p</em>,
<em>s<sub>p,h</sub></em> exclusively depends on <em>s<sub>p,h-1</sub></em> and <em>v<sub>p,h</sub></em>.</p>
  </li>
  <li>
    <p>Requirement 12 [<code class="language-plaintext highlighter-rouge">BeginBlock - DeliverTx - EndBlock</code>, determinism-2]: For any correct process <em>p</em>,
the contents of <em>T<sub>p,h</sub></em> exclusively depend on <em>s<sub>p,h-1</sub></em> and <em>v<sub>p,h</sub></em>.</p>
  </li>
</ul>

<p>Note that Requirements 11 and 12, combined with the Agreement property of consensus ensure
state machine replication, i.e., the Application state evolves consistently at all correct processes.</p>

<p>Finally, notice that <code class="language-plaintext highlighter-rouge">PrepareProposal</code> <!-- nor `ExtendVote` --> has determinism-related
requirements associated.
Indeed, <code class="language-plaintext highlighter-rouge">PrepareProposal</code> is not required to be deterministic:</p>

<ul>
  <li><em>u<sub>p</sub></em> may depend on <em>v<sub>p</sub></em> and <em>s<sub>p,h-1</sub></em>, but may also depend on other values or operations.</li>
  <li><em>v<sub>p</sub> = v<sub>q</sub> ‚áè u<sub>p</sub> = u<sub>q</sub></em>.</li>
</ul>

<!--
Likewise, `ExtendVote` can also be non-deterministic:

* *e<sup>r</sup><sub>p</sub>* may depend on *w<sup>r</sup><sub>p</sub>* and *s<sub>p,h-1</sub>*,
  but may also depend on other values or operations.
* *w<sup>r</sup><sub>p</sub> = w<sup>r</sup><sub>q</sub> &#8655;
  e<sup>r</sup><sub>p</sub> = e<sup>r</sup><sub>q</sub>*
-->
<h2 id="managing-the-application-state-and-related-topics">Managing the Application state and related topics</h2>

<h3 id="connection-state">Connection State</h3>

<p>CometBFT maintains four concurrent ABCI++ connections, namely
<a href="#consensus-connection">Consensus Connection</a>,
<a href="#mempool-connection">Mempool Connection</a>,
<a href="#infoquery-connection">Info/Query Connection</a>, and
<a href="#snapshot-connection">Snapshot Connection</a>.
It is common for an application to maintain a distinct copy of
the state for each connection, which are synchronized upon <code class="language-plaintext highlighter-rouge">Commit</code> calls.</p>

<h4 id="concurrency">Concurrency</h4>

<p>In principle, each of the four ABCI++ connections operates concurrently with one
another. This means applications need to ensure access to state is
thread safe. Both the
<a href="https://github.com/cometbft/cometbft/blob/main/abci/client/local_client.go#L13">default in-process ABCI client</a>
and the
<a href="https://github.com/cometbft/cometbft/blob/main/abci/server/socket_server.go#L20">default Go ABCI server</a>
use a global lock to guard the handling of events across all connections, so they are not
concurrent at all. This means whether your app is compiled in-process with
CometBFT using the <code class="language-plaintext highlighter-rouge">NewLocalClient</code>, or run out-of-process using the <code class="language-plaintext highlighter-rouge">SocketServer</code>,
ABCI messages from all connections are received in sequence, one at a
time.</p>

<p>The existence of this global mutex means Go application developers can get thread safety for application state by routing all reads and writes through the ABCI system. Thus it may be unsafe to expose application state directly to an RPC interface, and unless explicit measures are taken, all queries should be routed through the ABCI Query method.</p>

<!--
This is no longer the case starting from v0.36.0: the global locks have been removed and it is
up to the Application to synchronize access to its state when handling
ABCI++ methods on all connections.
 -->

<!--
 TODO CHeck with Sergio whether this is still the case
 -->
<!--
Nevertheless, as all ABCI calls are now synchronous, ABCI messages using the same connection are
still received in sequence.
 -->

<h4 id="beginblock---delivertx---endblock">BeginBlock - DeliverTx - EndBlock</h4>

<p>When the consensus algorithm decides on a block, CometBFT uses the sequence of calls to
<code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">DeliverTx</code> and <code class="language-plaintext highlighter-rouge">EndBlock</code> to send the
decided block‚Äôs data to the Application, which uses it to transition its state.</p>

<p>The sequence of <code class="language-plaintext highlighter-rouge">DeliverTx</code> calls is asynchronous but all those calls are enclosed by calls to <code class="language-plaintext highlighter-rouge">BeginBlock</code> and <code class="language-plaintext highlighter-rouge">EndBlock</code> which are synchronous.</p>

<p>The Application must remember the latest height from which it
has run a successful <code class="language-plaintext highlighter-rouge">Commit</code> so that it can tell CometBFT where to
pick up from when it recovers from a crash. See information on the Handshake
<a href="#crash-recovery">here</a>.</p>

<h4 id="commit">Commit</h4>

<p>The Application should persist its state during <code class="language-plaintext highlighter-rouge">Commit</code>, before returning from it.</p>

<p>Before invoking <code class="language-plaintext highlighter-rouge">Commit</code>, CometBFT locks the mempool and flushes the mempool connection. This ensures that
no new messages
will be received on the mempool connection during this processing step, providing an opportunity to safely
update all four
connection states to the latest committed state at the same time.</p>

<p>When <code class="language-plaintext highlighter-rouge">Commit</code> returns, CometBFT unlocks the mempool.</p>

<p>WARNING: if the ABCI app logic processing the <code class="language-plaintext highlighter-rouge">Commit</code> message sends a
<code class="language-plaintext highlighter-rouge">/broadcast_tx_sync</code> or <code class="language-plaintext highlighter-rouge">/broadcast_tx</code> and waits for the response
before proceeding, it will deadlock. Executing <code class="language-plaintext highlighter-rouge">broadcast_tx</code> calls
involves acquiring the mempool lock that CometBFT holds during the <code class="language-plaintext highlighter-rouge">Commit</code> call.
Synchronous mempool-related calls must be avoided as part of the sequential logic of the
<code class="language-plaintext highlighter-rouge">Commit</code> function.</p>

<h4 id="candidate-states">Candidate States</h4>

<p>CometBFT calls <code class="language-plaintext highlighter-rouge">PrepareProposal</code> when it is about to send a proposed block to the network.
Likewise, CometBFT calls <code class="language-plaintext highlighter-rouge">ProcessProposal</code> upon reception of a proposed block from the
network. The proposed block‚Äôs data
that is disclosed to the Application by these two methods is the following:</p>

<ul>
  <li>the transaction list</li>
  <li>the <code class="language-plaintext highlighter-rouge">LastCommit</code> referring to the previous block</li>
  <li>the block header‚Äôs hash (except in <code class="language-plaintext highlighter-rouge">PrepareProposal</code>, where it is not known yet)</li>
  <li>list of validators that misbehaved</li>
  <li>the block‚Äôs timestamp</li>
  <li><code class="language-plaintext highlighter-rouge">NextValidatorsHash</code></li>
  <li>Proposer address</li>
</ul>

<p>The Application may decide to <em>immediately</em> execute the given block (i.e., upon <code class="language-plaintext highlighter-rouge">PrepareProposal</code>
or <code class="language-plaintext highlighter-rouge">ProcessProposal</code>). There are two main reasons why the Application may want to do this:</p>

<ul>
  <li><em>Avoiding invalid transactions in blocks</em>.
In order to be sure that the block does not contain <em>any</em> invalid transaction, there may be
no way other than fully executing the transactions in the block as though it was the <em>decided</em>
block.</li>
  <li><em>Quick <code class="language-plaintext highlighter-rouge">BeginBlock-DeliverTx-EndBlock</code> execution</em>.
Upon reception of the decided block via <code class="language-plaintext highlighter-rouge">BeginBlock</code>, if that same block was executed
upon <code class="language-plaintext highlighter-rouge">PrepareProposal</code> or <code class="language-plaintext highlighter-rouge">ProcessProposal</code> and the resulting state was kept in memory, the
Application can simply apply that state (faster) to the main state, rather than reexecuting
the decided block (slower).</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">PrepareProposal</code>/<code class="language-plaintext highlighter-rouge">ProcessProposal</code> can be called many times for a given height. Moreover,
it is not possible to accurately predict which of the blocks proposed in a height will be decided,
being delivered to the Application in that height‚Äôs block execution calls.
Therefore, the state resulting from executing a proposed block, denoted a <em>candidate state</em>, should
be kept in memory as a possible final state for that height. When the block execution functions are called, the Application should
check if the decided block corresponds to one of its candidate states; if so, it will apply it as
its <em>ExecuteTxState</em> (see <a href="#consensus-connection">Consensus Connection</a> below),
which will be persisted during the upcoming <code class="language-plaintext highlighter-rouge">Commit</code> call.</p>

<p>Under adverse conditions (e.g., network instability), the consensus algorithm might take many rounds.
In this case, potentially many proposed blocks will be disclosed to the Application for a given height.
By the nature of Tendermint consensus algorithm, currently adopted in CometBFT, the number of proposed blocks received by the Application
for a particular height cannot be bound, so Application developers must act with care and use mechanisms
to bound memory usage. As a general rule, the Application should be ready to discard candidate states
before block execution, even if one of them might end up corresponding to the
decided block and thus have to be reexecuted upon <code class="language-plaintext highlighter-rouge">BeginBlock-DeliverTx-EndBlock</code>.</p>

<h3 id="states-and-abci-connections">States and ABCI++ Connections</h3>

<h4 id="consensus-connection">Consensus Connection</h4>

<p>The Consensus Connection should maintain an <em>ExecuteTxState</em> ‚Äî the working state
for block execution. It should be updated by the calls to the block execution functions
during block execution and committed to disk as the ‚Äúlatest
committed state‚Äù during <code class="language-plaintext highlighter-rouge">Commit</code>. Execution of a proposed block (via <code class="language-plaintext highlighter-rouge">PrepareProposal</code>/<code class="language-plaintext highlighter-rouge">ProcessProposal</code>)
<strong>must not</strong> update the <em>ExecuteTxState</em>, but rather be kept as a separate candidate state until <code class="language-plaintext highlighter-rouge">BeginBlock-DeliverTx-EndBlock</code>
confirms which of the candidate states (if any) can be used to update <em>ExecuteTxState</em>.</p>

<h4 id="mempool-connection">Mempool Connection</h4>

<p>The mempool Connection maintains <em>CheckTxState</em>. CometBFT sequentially processes an incoming
transaction (via RPC from client or P2P from the gossip layer) against <em>CheckTxState</em>.
If the processing does not return any error, the transaction is accepted into the mempool
and CometBFT starts gossipping it.
<em>CheckTxState</em> should be reset to the latest committed state
at the end of every <code class="language-plaintext highlighter-rouge">Commit</code>.</p>

<p>During the execution of a consensus instance, the <em>CheckTxState</em> may be updated concurrently with the
<em>ExecuteTxState</em>, as messages may be sent concurrently on the Consensus and Mempool connections.
At the end of the consensus instance, as described above, CometBFT locks the mempool and flushes
the mempool connection before calling <code class="language-plaintext highlighter-rouge">Commit</code>. This ensures that all pending <code class="language-plaintext highlighter-rouge">CheckTx</code> calls are
responded to and no new ones can begin.</p>

<p>After the <code class="language-plaintext highlighter-rouge">Commit</code> call returns, while still holding the mempool lock, <code class="language-plaintext highlighter-rouge">CheckTx</code> is run again on all
transactions that remain in the node‚Äôs local mempool after filtering those included in the block.
Parameter <code class="language-plaintext highlighter-rouge">Type</code> in <code class="language-plaintext highlighter-rouge">RequestCheckTx</code>
indicates whether an incoming transaction is new (<code class="language-plaintext highlighter-rouge">CheckTxType_New</code>), or a
recheck (<code class="language-plaintext highlighter-rouge">CheckTxType_Recheck</code>).</p>

<p>Finally, after re-checking transactions in the mempool, CometBFT will unlock
the mempool connection. New transactions are once again able to be processed through <code class="language-plaintext highlighter-rouge">CheckTx</code>.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">CheckTx</code> is just a weak filter to keep invalid transactions out of the mempool and,
utimately, ouf of the blockchain.
Since the transaction cannot be guaranteed to be checked against the exact same state as it
will be executed as part of a (potential) decided block, <code class="language-plaintext highlighter-rouge">CheckTx</code> shouldn‚Äôt check <em>everything</em>
that affects the transaction‚Äôs validity, in particular those checks whose validity may depend on
transaction ordering. <code class="language-plaintext highlighter-rouge">CheckTx</code> is weak because a Byzantine node need not care about <code class="language-plaintext highlighter-rouge">CheckTx</code>;
it can propose a block full of invalid transactions if it wants. The mechanism ABCI++ has
in place for dealing with such behavior is <code class="language-plaintext highlighter-rouge">ProcessProposal</code>.</p>

<h5 id="replay-protection">Replay Protection</h5>

<p>It is possible for old transactions to be sent again to the Application. This is typically
undesirable for all transactions, except for a generally small subset of them which are idempotent.</p>

<p>The mempool has a mechanism to prevent duplicated transactions from being processed.
This mechanism is nevertheless best-effort (currently based on the indexer)
and does not provide any guarantee of non duplication.
It is thus up to the Application to implement an application-specific
replay protection mechanism with strong guarantees as part of the logic in <code class="language-plaintext highlighter-rouge">CheckTx</code>.</p>

<h4 id="infoquery-connection">Info/Query Connection</h4>

<p>The Info (or Query) Connection should maintain a <code class="language-plaintext highlighter-rouge">QueryState</code>. This connection has two
purposes: 1) having the application answer the queries CometBFT receives from users
(see section <a href="#query">Query</a>),
and 2) synchronizing CometBFT and the Application at start up time (see
<a href="#crash-recovery">Crash Recovery</a>)
or after state sync (see <a href="#state-sync">State Sync</a>).</p>

<p><code class="language-plaintext highlighter-rouge">QueryState</code> is a read-only copy of <em>ExecuteTxState</em> as it was after the last
<code class="language-plaintext highlighter-rouge">Commit</code>, i.e.
after the full block has been processed and the state committed to disk.</p>

<h4 id="snapshot-connection">Snapshot Connection</h4>

<p>The Snapshot Connection is used to serve state sync snapshots for other nodes
and/or restore state sync snapshots to a local node being bootstrapped.
Snapshop management is optional: an Application may choose not to implement it.</p>

<p>For more information, see Section <a href="#state-sync">State Sync</a>.</p>

<h3 id="transaction-results">Transaction Results</h3>

<p>For each transaction within a block, the Application is expected to return a result within
<a href="./abci%2B%2B_methods.md#delivertx"><code class="language-plaintext highlighter-rouge">ResponseDeliverTx</code></a>.
<!--
The list of transactions executed must respect the same order as the list of transactions delivered via
subsequent calls to [`RequestDeliverTx`](./abci%2B%2B_methods.md#delivertx). 
-->
This section discusses the fields inside <code class="language-plaintext highlighter-rouge">ResponseDeliverTx</code> along with the fields in
<a href="./abci%2B%2B_methods.md#checktx"><code class="language-plaintext highlighter-rouge">ResponseCheckTx</code></a>,
whose semantics are similar.</p>

<p>The <code class="language-plaintext highlighter-rouge">Info</code> and <code class="language-plaintext highlighter-rouge">Log</code> fields are
non-deterministic values for debugging/convenience purposes. CometBFT logs them but they
are otherwise ignored.</p>

<h4 id="gas">Gas</h4>

<p>Ethereum introduced the notion of <em>gas</em> as an abstract representation of the
cost of the resources consumed by nodes when processing a transaction. Every operation in the
Ethereum Virtual Machine uses some amount of gas.
Gas has a market-variable price based on which miners can accept or reject to execute a
particular operation.</p>

<p>Users propose a maximum amount of gas for their transaction; if the transaction uses less, they get
the difference credited back. CometBFT adopts a similar abstraction,
though uses it only optionally and weakly, allowing applications to define
their own sense of the cost of execution.</p>

<p>In CometBFT, the <a href="#consensus-parameters">ConsensusParams.Block.MaxGas</a> limits the amount of
total gas that can be used by all transactions in a block.
The default value is <code class="language-plaintext highlighter-rouge">-1</code>, which means the block gas limit is not enforced, or that the concept of
gas is meaningless.</p>

<p>Responses contain a <code class="language-plaintext highlighter-rouge">GasWanted</code> and <code class="language-plaintext highlighter-rouge">GasUsed</code> field. The former is the maximum
amount of gas the sender of a transaction is willing to use, and the latter is how much it actually
used. Applications should enforce that <code class="language-plaintext highlighter-rouge">GasUsed &lt;= GasWanted</code> ‚Äî i.e. transaction execution
or validation should fail before it can use more resources than it requested.</p>

<p>When <code class="language-plaintext highlighter-rouge">MaxGas &gt; -1</code>, CometBFT enforces the following rules:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GasWanted &lt;= MaxGas</code> for every transaction in the mempool</li>
  <li><code class="language-plaintext highlighter-rouge">(sum of GasWanted in a block) &lt;= MaxGas</code> when proposing a block</li>
</ul>

<p>If <code class="language-plaintext highlighter-rouge">MaxGas == -1</code>, no rules about gas are enforced.</p>

<p>In v0.34.x and earlier versions, CometBFT does not enforce anything about Gas in consensus,
only in the mempool.
This means it does not guarantee that committed blocks satisfy these rules.
It is the application‚Äôs responsibility to return non-zero response codes when gas limits are exceeded
when executing the transactions of a block.
Since the introduction of <code class="language-plaintext highlighter-rouge">PrepareProposal</code> and <code class="language-plaintext highlighter-rouge">ProcessProposal</code> in v.0.37.x, it is now possible
for the Application to enforce that all blocks proposed (and voted for) in consensus ‚Äî and thus all
blocks decided ‚Äî respect the <code class="language-plaintext highlighter-rouge">MaxGas</code> limits described above.</p>

<p>Since the Application should enforce that <code class="language-plaintext highlighter-rouge">GasUsed &lt;= GasWanted</code> when executing a transaction, and
it can use <code class="language-plaintext highlighter-rouge">PrepareProposal</code> and <code class="language-plaintext highlighter-rouge">ProcessProposal</code> to enforce that <code class="language-plaintext highlighter-rouge">(sum of GasWanted in a block) &lt;= MaxGas</code>
in all proposed or prevoted blocks,
we have:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(sum of GasUsed in a block) &lt;= MaxGas</code> for every block</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">GasUsed</code> field is ignored by CometBFT.</p>

<h4 id="specifics-of-responsechecktx">Specifics of <code class="language-plaintext highlighter-rouge">ResponseCheckTx</code></h4>

<p>If <code class="language-plaintext highlighter-rouge">Code != 0</code>, it will be rejected from the mempool and hence
not broadcasted to other peers and not included in a proposal block.</p>

<p><code class="language-plaintext highlighter-rouge">Data</code> contains the result of the <code class="language-plaintext highlighter-rouge">CheckTx</code> transaction execution, if any. It does not need to be
deterministic since, given a transaction, nodes‚Äô Applications
might have a different <em>CheckTxState</em> values when they receive it and check their validity
via <code class="language-plaintext highlighter-rouge">CheckTx</code>.
CometBFT ignores this value in <code class="language-plaintext highlighter-rouge">ResponseCheckTx</code>.</p>

<p>From v0.34.x on, there is a <code class="language-plaintext highlighter-rouge">Priority</code> field in <code class="language-plaintext highlighter-rouge">ResponseCheckTx</code> that can be
used to explicitly prioritize transactions in the mempool for inclusion in a block
proposal.</p>

<h4 id="specifics-of-responsedelivertx">Specifics of <code class="language-plaintext highlighter-rouge">ResponseDeliverTx</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">BeginBlock-DeliverTx-EndBlock</code> sequence is the workhorse of the blockchain.
A sequence of <code class="language-plaintext highlighter-rouge">DeliverTx</code> calls delivers the decided block,
one transaction at a time, to the Application.
The block delivered (and thus the transaction order) is the same at all correct nodes as guaranteed
by the Agreement property of consensus.</p>

<p>The <code class="language-plaintext highlighter-rouge">Data</code> field contains an array of bytes with the transaction result.
It must be deterministic (i.e., the same value must be returned at all nodes), but it can contain arbitrary
data. Likewise, the value of <code class="language-plaintext highlighter-rouge">Code</code> must be deterministic.
If <code class="language-plaintext highlighter-rouge">Code != 0</code>, the transaction will be marked invalid,
though it is still included in the block. Invalid transactions are not indexed, as they are
considered analogous to those that failed <code class="language-plaintext highlighter-rouge">CheckTx</code>.</p>

<p>Both the <code class="language-plaintext highlighter-rouge">Code</code> and <code class="language-plaintext highlighter-rouge">Data</code> are included in a structure that is hashed into the
<code class="language-plaintext highlighter-rouge">LastResultsHash</code> of the block header in the next height.</p>

<p><code class="language-plaintext highlighter-rouge">Events</code> include any events for the execution, which CometBFT will use to index
the transaction by. This allows transactions to be queried according to what
events took place during their execution.</p>

<h3 id="updating-the-validator-set">Updating the Validator Set</h3>

<p>The application may set the validator set during
<a href="./abci%2B%2B_methods.md#initchain"><code class="language-plaintext highlighter-rouge">InitChain</code></a>, and may update it during
<a href="./abci%2B%2B_methods.md#endblock"><code class="language-plaintext highlighter-rouge">EndBlock</code></a>. In both cases, a structure of type
<a href="./abci%2B%2B_methods.md#validatorupdate"><code class="language-plaintext highlighter-rouge">ValidatorUpdate</code></a> is returned.</p>

<p>The <code class="language-plaintext highlighter-rouge">InitChain</code> method, used to initialize the Application, can return a list of validators.
If the list is empty, CometBFT will use the validators loaded from the genesis
file.
If the list returned by <code class="language-plaintext highlighter-rouge">InitChain</code> is not empty, CometBFT will use its contents as the validator set.
This way the application can set the initial validator set for the
blockchain.</p>

<p>Applications must ensure that a single set of validator updates does not contain duplicates, i.e.
a given public key can only appear once within a given update. If an update includes
duplicates, the block execution will fail irrecoverably.</p>

<p>Structure <code class="language-plaintext highlighter-rouge">ValidatorUpdate</code> contains a public key, which is used to identify the validator:
The public key currently supports three types:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ed25519</code></li>
  <li><code class="language-plaintext highlighter-rouge">secp256k1</code></li>
  <li><code class="language-plaintext highlighter-rouge">sr25519</code></li>
</ul>

<p>Structure <code class="language-plaintext highlighter-rouge">ValidatorUpdate</code> also contains an <code class="language-plaintext highlighter-rouge">√¨nt64</code> field denoting the validator‚Äôs new power.
Applications must ensure that
<code class="language-plaintext highlighter-rouge">ValidatorUpdate</code> structures abide by the following rules:</p>

<ul>
  <li>power must be non-negative</li>
  <li>if power is set to 0, the validator must be in the validator set; it will be removed from the set</li>
  <li>if power is greater than 0:
    <ul>
      <li>if the validator is not in the validator set, it will be added to the
set with the given power</li>
      <li>if the validator is in the validator set, its power will be adjusted to the given power</li>
    </ul>
  </li>
  <li>the total power of the new validator set must not exceed <code class="language-plaintext highlighter-rouge">MaxTotalVotingPower</code>, where
<code class="language-plaintext highlighter-rouge">MaxTotalVotingPower = MaxInt64 / 8</code></li>
</ul>

<p>Note the updates returned after processing the block at height <code class="language-plaintext highlighter-rouge">H</code> will only take effect
at block <code class="language-plaintext highlighter-rouge">H+2</code> (see Section <a href="./abci%2B%2B_methods.md">Methods</a>).</p>

<h3 id="consensus-parameters">Consensus Parameters</h3>

<p><code class="language-plaintext highlighter-rouge">ConsensusParams</code> are global parameters that apply to all validators in a blockchain.
They enforce certain limits in the blockchain, like the maximum size
of blocks, amount of gas used in a block, and the maximum acceptable age of
evidence. They can be set in
<a href="./abci%2B%2B_methods.md#initchain"><code class="language-plaintext highlighter-rouge">InitChain</code></a>, and updated in
<a href="./abci%2B%2B_methods.md#endblock"><code class="language-plaintext highlighter-rouge">EndBlock</code></a>.
These parameters are deterministically set and/or updated by the Application, so
all full nodes have the same value at a given height.</p>

<h4 id="list-of-parameters">List of Parameters</h4>

<p>These are the current consensus parameters (as of v0.37.x):</p>

<ol>
  <li><a href="#blockparamsmaxbytes">BlockParams.MaxBytes</a></li>
  <li><a href="#blockparamsmaxgas">BlockParams.MaxGas</a></li>
  <li><a href="#evidenceparamsmaxageduration">EvidenceParams.MaxAgeDuration</a></li>
  <li><a href="#evidenceparamsmaxagenumblocks">EvidenceParams.MaxAgeNumBlocks</a></li>
  <li><a href="#evidenceparamsmaxbytes">EvidenceParams.MaxBytes</a></li>
  <li><a href="#validatorparamspubkeytypes">ValidatorParams.PubKeyTypes</a></li>
  <li><a href="#versionparamsapp">VersionParams.App</a>
&lt;!‚Äì</li>
  <li><a href="#synchronyparamsmessagedelay">SynchronyParams.MessageDelay</a></li>
  <li><a href="#synchronyparamsprecision">SynchronyParams.Precision</a></li>
  <li><a href="#timeoutparamspropose">TimeoutParams.Propose</a></li>
  <li><a href="#timeoutparamsproposedelta">TimeoutParams.ProposeDelta</a></li>
  <li><a href="#timeoutparamsvote">TimeoutParams.Vote</a></li>
  <li><a href="#timeoutparamsvotedelta">TimeoutParams.VoteDelta</a></li>
  <li><a href="#timeoutparamscommit">TimeoutParams.Commit</a></li>
  <li><a href="#timeoutparamsbypasscommittimeout">TimeoutParams.BypassCommitTimeout</a> 
‚Äì&gt;</li>
</ol>

<h5 id="blockparamsmaxbytes">BlockParams.MaxBytes</h5>

<p>The maximum size of a complete Protobuf encoded block.
This is enforced by the consensus algorithm.</p>

<p>This implies a maximum transaction size that is this <code class="language-plaintext highlighter-rouge">MaxBytes</code>, less the expected size of
the header, the validator set, and any included evidence in the block.</p>

<p>Must have <code class="language-plaintext highlighter-rouge">0 &lt; MaxBytes &lt; 100 MB</code>.</p>

<h5 id="blockparamsmaxgas">BlockParams.MaxGas</h5>

<p>The maximum of the sum of <code class="language-plaintext highlighter-rouge">GasWanted</code> that will be allowed in a proposed block.
This is <em>not</em> enforced by the consensus algorithm.
It is left to the Application to enforce (ie. if transactions are included past the
limit, they should return non-zero codes). It is used by CometBFT to limit the
transactions included in a proposed block.</p>

<p>Must have <code class="language-plaintext highlighter-rouge">MaxGas &gt;= -1</code>.
If <code class="language-plaintext highlighter-rouge">MaxGas == -1</code>, no limit is enforced.</p>

<h5 id="evidenceparamsmaxageduration">EvidenceParams.MaxAgeDuration</h5>

<p>This is the maximum age of evidence in time units.
This is enforced by the consensus algorithm.</p>

<p>If a block includes evidence older than this (AND the evidence was created more
than <code class="language-plaintext highlighter-rouge">MaxAgeNumBlocks</code> ago), the block will be rejected (validators won‚Äôt vote
for it).</p>

<p>Must have <code class="language-plaintext highlighter-rouge">MaxAgeDuration &gt; 0</code>.</p>

<h5 id="evidenceparamsmaxagenumblocks">EvidenceParams.MaxAgeNumBlocks</h5>

<p>This is the maximum age of evidence in blocks.
This is enforced by the consensus algorithm.</p>

<p>If a block includes evidence older than this (AND the evidence was created more
than <code class="language-plaintext highlighter-rouge">MaxAgeDuration</code> ago), the block will be rejected (validators won‚Äôt vote
for it).</p>

<p>Must have <code class="language-plaintext highlighter-rouge">MaxAgeNumBlocks &gt; 0</code>.</p>

<h5 id="evidenceparamsmaxbytes">EvidenceParams.MaxBytes</h5>

<p>This is the maximum size of total evidence in bytes that can be committed to a
single block. It should fall comfortably under the max block bytes.</p>

<p>Its value must not exceed the size of
a block minus its overhead ( ~ <code class="language-plaintext highlighter-rouge">BlockParams.MaxBytes</code>).</p>

<p>Must have <code class="language-plaintext highlighter-rouge">MaxBytes &gt; 0</code>.</p>

<h5 id="validatorparamspubkeytypes">ValidatorParams.PubKeyTypes</h5>

<p>The parameter restricts the type of keys validators can use. The parameter uses ABCI pubkey naming, not Amino names.</p>

<h5 id="versionparamsapp">VersionParams.App</h5>

<p>This is the version of the ABCI application.
&lt;!‚Äì</p>
<h5 id="synchronyparamsmessagedelay">SynchronyParams.MessageDelay</h5>

<p>This sets a bound on how long a proposal message may take to reach all
validators on a network and still be considered valid.</p>

<p>This parameter is part of the
<a href="../consensus/proposer-based-timestamp">proposer-based timestamps</a>
(PBTS) algorithm.</p>

<h5 id="synchronyparamsprecision">SynchronyParams.Precision</h5>

<p>This sets a bound on how skewed a proposer‚Äôs clock may be from any validator
on the network while still producing valid proposals.</p>

<p>This parameter is part of the
<a href="../consensus/proposer-based-timestamp">proposer-based timestamps</a>
(PBTS) algorithm.</p>

<h5 id="timeoutparamspropose">TimeoutParams.Propose</h5>

<p>Timeout in ms of the propose step of Tendermint consensus algorithm.
This value is the initial timeout at every height (round 0).</p>

<p>The value in subsequent rounds is modified by parameter <code class="language-plaintext highlighter-rouge">ProposeDelta</code>.
When a new height is started, the <code class="language-plaintext highlighter-rouge">Propose</code> timeout value is reset to this
parameter.</p>

<p>If a node waiting for a proposal message does not receive one matching its
current height and round before this timeout, the node will issue a
<code class="language-plaintext highlighter-rouge">nil</code> prevote for the round and advance to the next step.</p>

<h5 id="timeoutparamsproposedelta">TimeoutParams.ProposeDelta</h5>

<p>Increment in ms to be added to the <code class="language-plaintext highlighter-rouge">Propose</code> timeout every time Tendermint
consensus algorithm advances one round in a given height.</p>

<p>When a new height is started, the <code class="language-plaintext highlighter-rouge">Propose</code> timeout value is reset.</p>

<h5 id="timeoutparamsvote">TimeoutParams.Vote</h5>

<p>Timeout in ms of the prevote and precommit steps of Tendermint consensus
algorithm.
This value is the initial timeout at every height (round 0).</p>

<p>The value in subsequent rounds is modified by parameter <code class="language-plaintext highlighter-rouge">VoteDelta</code>.
When a new height is started, the <code class="language-plaintext highlighter-rouge">Vote</code> timeout value is reset to this
parameter.</p>

<p>The <code class="language-plaintext highlighter-rouge">Vote</code> timeout does not begin until a quorum of votes has been received.
Once a quorum of votes has been seen and this timeout elapses, Tendermint will
procced to the next step of the consensus algorithm. If Tendermint receives
all of the remaining votes before the end of the timeout, it will proceed
to the next step immediately.</p>

<h5 id="timeoutparamsvotedelta">TimeoutParams.VoteDelta</h5>

<p>Increment in ms to be added to the <code class="language-plaintext highlighter-rouge">Vote</code> timeout every time Tendermint
consensus algorithm advances one round in a given height.</p>

<p>When a new height is started, the <code class="language-plaintext highlighter-rouge">Vote</code> timeout value is reset.</p>

<h5 id="timeoutparamscommit">TimeoutParams.Commit</h5>

<p>This configures how long Tendermint consensus algorithm will wait after receiving a quorum of
precommits before beginning consensus for the next height. This can be
used to allow slow precommits to arrive for inclusion in the next height
before progressing.</p>

<h5 id="timeoutparamsbypasscommittimeout">TimeoutParams.BypassCommitTimeout</h5>

<p>This configures the node to proceed immediately to the next height once the
node has received all precommits for a block, forgoing the remaining commit timeout.
Setting this parameter to <code class="language-plaintext highlighter-rouge">false</code> (the default) causes Tendermint to wait
for the full commit timeout configured in <code class="language-plaintext highlighter-rouge">TimeoutParams.Commit</code>.
‚Äì&gt;
&lt;!‚Äì</p>
<h5 id="abciparamsvoteextensionsenableheight">ABCIParams.VoteExtensionsEnableHeight</h5>

<p>This parameter is either 0 or a positive height at which vote extensions
become mandatory. If the value is zero (which is the default), vote
extensions are not required. Otherwise, at all heights greater than the
configured height <code class="language-plaintext highlighter-rouge">H</code> vote extensions must be present (even if empty).
When the configured height <code class="language-plaintext highlighter-rouge">H</code> is reached, <code class="language-plaintext highlighter-rouge">PrepareProposal</code> will not
include vote extensions yet, but <code class="language-plaintext highlighter-rouge">ExtendVote</code> and <code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> will
be called. Then, when reaching height <code class="language-plaintext highlighter-rouge">H+1</code>, <code class="language-plaintext highlighter-rouge">PrepareProposal</code> will
include the vote extensions from height <code class="language-plaintext highlighter-rouge">H</code>. For all heights after <code class="language-plaintext highlighter-rouge">H</code></p>

<ul>
  <li>vote extensions cannot be disabled,</li>
  <li>they are mandatory: all precommit messages sent MUST have an extension
attached. Nevetheless, the application MAY provide 0-length
extensions.</li>
</ul>

<p>Must always be set to a future height. Once set to a value different from
0, its value must not be changed.
‚Äì&gt;</p>
<h4 id="updating-consensus-parameters">Updating Consensus Parameters</h4>

<p>The application may set the <code class="language-plaintext highlighter-rouge">ConsensusParams</code> during
<a href="./abci%2B%2B_methods.md#initchain"><code class="language-plaintext highlighter-rouge">InitChain</code></a>,
and update them during
<a href="./abci%2B%2B_methods.md#endblock"><code class="language-plaintext highlighter-rouge">EndBlock</code></a>.
If the <code class="language-plaintext highlighter-rouge">ConsensusParams</code> is empty, it will be ignored. Each field
that is not empty will be applied in full. For instance, if updating the
<code class="language-plaintext highlighter-rouge">Block.MaxBytes</code>, applications must also set the other <code class="language-plaintext highlighter-rouge">Block</code> fields (like
<code class="language-plaintext highlighter-rouge">Block.MaxGas</code>), even if they are unchanged, as they will otherwise cause the
value to be updated to the default.</p>

<h5 id="initchain"><code class="language-plaintext highlighter-rouge">InitChain</code></h5>

<p><code class="language-plaintext highlighter-rouge">ResponseInitChain</code> includes a <code class="language-plaintext highlighter-rouge">ConsensusParams</code> parameter.
If <code class="language-plaintext highlighter-rouge">ConsensusParams</code> is <code class="language-plaintext highlighter-rouge">nil</code>, CometBFT will use the params loaded in the genesis
file. If <code class="language-plaintext highlighter-rouge">ConsensusParams</code> is not <code class="language-plaintext highlighter-rouge">nil</code>, CometBFT will use it.
This way the application can determine the initial consensus parameters for the
blockchain.</p>

<h5 id="endblock-prepareproposalprocessproposal"><code class="language-plaintext highlighter-rouge">EndBlock</code>, <code class="language-plaintext highlighter-rouge">PrepareProposal</code>/<code class="language-plaintext highlighter-rouge">ProcessProposal</code></h5>

<p><code class="language-plaintext highlighter-rouge">ResponseEndBlock</code> accepts a <code class="language-plaintext highlighter-rouge">ConsensusParams</code> parameter.
If <code class="language-plaintext highlighter-rouge">ConsensusParams</code> is <code class="language-plaintext highlighter-rouge">nil</code>, CometBFT will do nothing.
If <code class="language-plaintext highlighter-rouge">ConsensusParams</code> is not <code class="language-plaintext highlighter-rouge">nil</code>, CometBFT will use it.
This way the application can update the consensus parameters over time.</p>

<p>The updates returned in block <code class="language-plaintext highlighter-rouge">H</code> will take effect right away for block
<code class="language-plaintext highlighter-rouge">H+1</code>.</p>

<h3 id="query"><code class="language-plaintext highlighter-rouge">Query</code></h3>

<p><code class="language-plaintext highlighter-rouge">Query</code> is a generic method with lots of flexibility to enable diverse sets
of queries on application state. CometBFT makes use of <code class="language-plaintext highlighter-rouge">Query</code> to filter new peers
based on ID and IP, and exposes <code class="language-plaintext highlighter-rouge">Query</code> to the user over RPC.</p>

<p>Note that calls to <code class="language-plaintext highlighter-rouge">Query</code> are not replicated across nodes, but rather query the
local node‚Äôs state - hence they may return stale reads. For reads that require
consensus, use a transaction.</p>

<p>The most important use of <code class="language-plaintext highlighter-rouge">Query</code> is to return Merkle proofs of the application state at some height
that can be used for efficient application-specific light-clients.</p>

<p>Note CometBFT has technically no requirements from the <code class="language-plaintext highlighter-rouge">Query</code>
message for normal operation - that is, the ABCI app developer need not implement
Query functionality if they do not wish to.</p>

<h4 id="query-proofs">Query Proofs</h4>

<p>The CometBFT block header includes a number of hashes, each providing an
anchor for some type of proof about the blockchain. The <code class="language-plaintext highlighter-rouge">ValidatorsHash</code> enables
quick verification of the validator set, the <code class="language-plaintext highlighter-rouge">DataHash</code> gives quick
verification of the transactions included in the block.</p>

<p>The <code class="language-plaintext highlighter-rouge">AppHash</code> is unique in that it is application specific, and allows for
application-specific Merkle proofs about the state of the application.
While some applications keep all relevant state in the transactions themselves
(like Bitcoin and its UTXOs), others maintain a separated state that is
computed deterministically <em>from</em> transactions, but is not contained directly in
the transactions themselves (like Ethereum contracts and accounts).
For such applications, the <code class="language-plaintext highlighter-rouge">AppHash</code> provides a much more efficient way to verify light-client proofs.</p>

<p>ABCI applications can take advantage of more efficient light-client proofs for
their state as follows:</p>

<ul>
  <li>return the Merkle root of the deterministic application state in
<code class="language-plaintext highlighter-rouge">Commit.Data</code>. This Merkle root will be included as the <code class="language-plaintext highlighter-rouge">AppHash</code> in the next block.</li>
  <li>return efficient Merkle proofs about that application state in <code class="language-plaintext highlighter-rouge">ResponseQuery.Proof</code>
that can be verified using the <code class="language-plaintext highlighter-rouge">AppHash</code> of the corresponding block.</li>
</ul>

<p>For instance, this allows an application‚Äôs light-client to verify proofs of
absence in the application state, something which is much less efficient to do using the block hash.</p>

<p>Some applications (eg. Ethereum, Cosmos-SDK) have multiple ‚Äúlevels‚Äù of Merkle trees,
where the leaves of one tree are the root hashes of others. To support this, and
the general variability in Merkle proofs, the <code class="language-plaintext highlighter-rouge">ResponseQuery.Proof</code> has some minimal structure:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">ProofOps</span> <span class="p">{</span>
  <span class="k">repeated</span> <span class="n">ProofOp</span> <span class="na">ops</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">message</span> <span class="nc">ProofOp</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">bytes</span> <span class="na">key</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">bytes</span> <span class="na">data</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each <code class="language-plaintext highlighter-rouge">ProofOp</code> contains a proof for a single key in a single Merkle tree, of the specified <code class="language-plaintext highlighter-rouge">type</code>.
This allows ABCI to support many different kinds of Merkle trees, encoding
formats, and proofs (eg. of presence and absence) just by varying the <code class="language-plaintext highlighter-rouge">type</code>.
The <code class="language-plaintext highlighter-rouge">data</code> contains the actual encoded proof, encoded according to the <code class="language-plaintext highlighter-rouge">type</code>.
When verifying the full proof, the root hash for one ProofOp is the value being
verified for the next ProofOp in the list. The root hash of the final ProofOp in
the list should match the <code class="language-plaintext highlighter-rouge">AppHash</code> being verified against.</p>

<h4 id="peer-filtering">Peer Filtering</h4>

<p>When CometBFT connects to a peer, it sends two queries to the ABCI application
using the following paths, with no additional data:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/p2p/filter/addr/&lt;IP:PORT&gt;</code>, where <code class="language-plaintext highlighter-rouge">&lt;IP:PORT&gt;</code> denote the IP address and
the port of the connection</li>
  <li><code class="language-plaintext highlighter-rouge">p2p/filter/id/&lt;ID&gt;</code>, where <code class="language-plaintext highlighter-rouge">&lt;ID&gt;</code> is the peer node ID (ie. the
pubkey.Address() for the peer‚Äôs PubKey)</li>
</ul>

<p>If either of these queries return a non-zero ABCI code, CometBFT will refuse
to connect to the peer.</p>

<h4 id="paths">Paths</h4>

<p>Queries are directed at paths, and may optionally include additional data.</p>

<p>The expectation is for there to be some number of high level paths
differentiating concerns, like <code class="language-plaintext highlighter-rouge">/p2p</code>, <code class="language-plaintext highlighter-rouge">/store</code>, and <code class="language-plaintext highlighter-rouge">/app</code>. Currently,
CometBFT only uses <code class="language-plaintext highlighter-rouge">/p2p</code>, for filtering peers. For more advanced use, see the
implementation of
<a href="https://github.com/cosmos/cosmos-sdk/blob/v0.23.1/baseapp/baseapp.go#L333">Query in the Cosmos-SDK</a>.</p>

<h3 id="crash-recovery">Crash Recovery</h3>

<p>On startup, CometBFT calls the <code class="language-plaintext highlighter-rouge">Info</code> method on the Info Connection to get the latest
committed state of the app. The app MUST return information consistent with the
last block it succesfully completed Commit for.</p>

<p>If the app succesfully committed block H, then <code class="language-plaintext highlighter-rouge">last_block_height = H</code> and <code class="language-plaintext highlighter-rouge">last_block_app_hash = &lt;hash returned by Commit for block H&gt;</code>. If the app
failed during the Commit of block H, then <code class="language-plaintext highlighter-rouge">last_block_height = H-1</code> and
<code class="language-plaintext highlighter-rouge">last_block_app_hash = &lt;hash returned by Commit for block H-1, which is the hash in the header of block H&gt;</code>.</p>

<p>We now distinguish three heights, and describe how CometBFT syncs itself with
the app.</p>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code>storeBlockHeight = height of the last block CometBFT saw a commit for
stateBlockHeight = height of the last block for which CometBFT completed all
    block processing and saved all ABCI results to disk
appBlockHeight = height of the last block for which ABCI app succesfully
    completed Commit

</code></pre></div></div>

<p>Note we always have <code class="language-plaintext highlighter-rouge">storeBlockHeight &gt;= stateBlockHeight</code> and <code class="language-plaintext highlighter-rouge">storeBlockHeight &gt;= appBlockHeight</code>
Note also CometBFT never calls Commit on an ABCI app twice for the same height.</p>

<p>The procedure is as follows.</p>

<p>First, some simple start conditions:</p>

<p>If <code class="language-plaintext highlighter-rouge">appBlockHeight == 0</code>, then call InitChain.</p>

<p>If <code class="language-plaintext highlighter-rouge">storeBlockHeight == 0</code>, we‚Äôre done.</p>

<p>Now, some sanity checks:</p>

<p>If <code class="language-plaintext highlighter-rouge">storeBlockHeight &lt; appBlockHeight</code>, error
If <code class="language-plaintext highlighter-rouge">storeBlockHeight &lt; stateBlockHeight</code>, panic
If <code class="language-plaintext highlighter-rouge">storeBlockHeight &gt; stateBlockHeight+1</code>, panic</p>

<p>Now, the meat:</p>

<p>If <code class="language-plaintext highlighter-rouge">storeBlockHeight == stateBlockHeight &amp;&amp; appBlockHeight &lt; storeBlockHeight</code>,
replay all blocks in full from <code class="language-plaintext highlighter-rouge">appBlockHeight</code> to <code class="language-plaintext highlighter-rouge">storeBlockHeight</code>.
This happens if we completed processing the block, but the app forgot its height.</p>

<p>If <code class="language-plaintext highlighter-rouge">storeBlockHeight == stateBlockHeight &amp;&amp; appBlockHeight == storeBlockHeight</code>, we‚Äôre done.
This happens if we crashed at an opportune spot.</p>

<p>If <code class="language-plaintext highlighter-rouge">storeBlockHeight == stateBlockHeight+1</code>
This happens if we started processing the block but didn‚Äôt finish.</p>

<p>If <code class="language-plaintext highlighter-rouge">appBlockHeight &lt; stateBlockHeight</code>
    replay all blocks in full from <code class="language-plaintext highlighter-rouge">appBlockHeight</code> to <code class="language-plaintext highlighter-rouge">storeBlockHeight-1</code>,
    and replay the block at <code class="language-plaintext highlighter-rouge">storeBlockHeight</code> using the WAL.
This happens if the app forgot the last block it committed.</p>

<p>If <code class="language-plaintext highlighter-rouge">appBlockHeight == stateBlockHeight</code>,
    replay the last block (storeBlockHeight) in full.
This happens if we crashed before the app finished Commit</p>

<p>If <code class="language-plaintext highlighter-rouge">appBlockHeight == storeBlockHeight</code>
    update the state using the saved ABCI responses but dont run the block against the real app.
This happens if we crashed after the app finished Commit but before CometBFT saved the state.</p>

<h3 id="state-sync">State Sync</h3>

<p>A new node joining the network can simply join consensus at the genesis height and replay all
historical blocks until it is caught up. However, for large chains this can take a significant
amount of time, often on the order of days or weeks.</p>

<p>State sync is an alternative mechanism for bootstrapping a new node, where it fetches a snapshot
of the state machine at a given height and restores it. Depending on the application, this can
be several orders of magnitude faster than replaying blocks.</p>

<p>Note that state sync does not currently backfill historical blocks, so the node will have a
truncated block history - users are advised to consider the broader network implications of this in
terms of block availability and auditability. This functionality may be added in the future.</p>

<p>For details on the specific ABCI calls and types, see the
<a href="abci%2B%2B_methods.md">methods</a> section.</p>

<h4 id="taking-snapshots">Taking Snapshots</h4>

<p>Applications that want to support state syncing must take state snapshots at regular intervals. How
this is accomplished is entirely up to the application. A snapshot consists of some metadata and
a set of binary chunks in an arbitrary format:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Height (uint64)</code>: The height at which the snapshot is taken. It must be taken after the given
height has been committed, and must not contain data from any later heights.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Format (uint32)</code>: An arbitrary snapshot format identifier. This can be used to version snapshot
formats, e.g. to switch from Protobuf to MessagePack for serialization. The application can use
this when restoring to choose whether to accept or reject a snapshot.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Chunks (uint32)</code>: The number of chunks in the snapshot. Each chunk contains arbitrary binary
data, and should be less than 16 MB; 10 MB is a good starting point.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Hash ([]byte)</code>: An arbitrary hash of the snapshot. This is used to check whether a snapshot is
the same across nodes when downloading chunks.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Metadata ([]byte)</code>: Arbitrary snapshot metadata, e.g. chunk hashes for verification or any other
necessary info.</p>
  </li>
</ul>

<p>For a snapshot to be considered the same across nodes, all of these fields must be identical. When
sent across the network, snapshot metadata messages are limited to 4 MB.</p>

<p>When a new node is running state sync and discovering snapshots, CometBFT will query an existing
application via the ABCI <code class="language-plaintext highlighter-rouge">ListSnapshots</code> method to discover available snapshots, and load binary
snapshot chunks via <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code>. The application is free to choose how to implement this
and which formats to use, but must provide the following guarantees:</p>

<ul>
  <li>
    <p><strong>Consistent:</strong> A snapshot must be taken at a single isolated height, unaffected by
concurrent writes. This can be accomplished by using a data store that supports ACID
transactions with snapshot isolation.</p>
  </li>
  <li>
    <p><strong>Asynchronous:</strong> Taking a snapshot can be time-consuming, so it must not halt chain progress,
for example by running in a separate thread.</p>
  </li>
  <li>
    <p><strong>Deterministic:</strong> A snapshot taken at the same height in the same format must be identical
(at the byte level) across nodes, including all metadata. This ensures good availability of
chunks, and that they fit together across nodes.</p>
  </li>
</ul>

<p>A very basic approach might be to use a datastore with MVCC transactions (such as RocksDB),
start a transaction immediately after block commit, and spawn a new thread which is passed the
transaction handle. This thread can then export all data items, serialize them using e.g.
Protobuf, hash the byte stream, split it into chunks, and store the chunks in the file system
along with some metadata - all while the blockchain is applying new blocks in parallel.</p>

<p>A more advanced approach might include incremental verification of individual chunks against the
chain app hash, parallel or batched exports, compression, and so on.</p>

<p>Old snapshots should be removed after some time - generally only the last two snapshots are needed
(to prevent the last one from being removed while a node is restoring it).</p>

<h4 id="bootstrapping-a-node">Bootstrapping a Node</h4>

<p>An empty node can be state synced by setting the configuration option <code class="language-plaintext highlighter-rouge">statesync.enabled =
true</code>. The node also needs the chain genesis file for basic chain info, and configuration for
light client verification of the restored snapshot: a set of CometBFT RPC servers, and a
trusted header hash and corresponding height from a trusted source, via the <code class="language-plaintext highlighter-rouge">statesync</code>
configuration section.</p>

<p>Once started, the node will connect to the P2P network and begin discovering snapshots. These
will be offered to the local application via the <code class="language-plaintext highlighter-rouge">OfferSnapshot</code> ABCI method. Once a snapshot
is accepted CometBFT will fetch and apply the snapshot chunks. After all chunks have been
successfully applied, CometBFT verifies the app‚Äôs <code class="language-plaintext highlighter-rouge">AppHash</code> against the chain using the light
client, then switches the node to normal consensus operation.</p>

<h5 id="snapshot-discovery">Snapshot Discovery</h5>

<p>When the empty node joins the P2P network, it asks all peers to report snapshots via the
<code class="language-plaintext highlighter-rouge">ListSnapshots</code> ABCI call (limited to 10 per node). After some time, the node picks the most
suitable snapshot (generally prioritized by height, format, and number of peers), and offers it
to the application via <code class="language-plaintext highlighter-rouge">OfferSnapshot</code>. The application can choose a number of responses,
including accepting or rejecting it, rejecting the offered format, rejecting the peer who sent
it, and so on. CometBFT will keep discovering and offering snapshots until one is accepted or
the application aborts.</p>

<h5 id="snapshot-restoration">Snapshot Restoration</h5>

<p>Once a snapshot has been accepted via <code class="language-plaintext highlighter-rouge">OfferSnapshot</code>, CometBFT begins downloading chunks from
any peers that have the same snapshot (i.e. that have identical metadata fields). Chunks are
spooled in a temporary directory, and then given to the application in sequential order via
<code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> until all chunks have been accepted.</p>

<p>The method for restoring snapshot chunks is entirely up to the application.</p>

<p>During restoration, the application can respond to <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code> with instructions for how
to continue. This will typically be to accept the chunk and await the next one, but it can also
ask for chunks to be refetched (either the current one or any number of previous ones), P2P peers
to be banned, snapshots to be rejected or retried, and a number of other responses - see the ABCI
reference for details.</p>

<p>If CometBFT fails to fetch a chunk after some time, it will reject the snapshot and try a
different one via <code class="language-plaintext highlighter-rouge">OfferSnapshot</code> - the application can choose whether it wants to support
restarting restoration, or simply abort with an error.</p>

<h5 id="snapshot-verification">Snapshot Verification</h5>

<p>Once all chunks have been accepted, CometBFT issues an <code class="language-plaintext highlighter-rouge">Info</code> ABCI call to retrieve the
<code class="language-plaintext highlighter-rouge">LastBlockAppHash</code>. This is compared with the trusted app hash from the chain, retrieved and
verified using the light client. CometBFT also checks that <code class="language-plaintext highlighter-rouge">LastBlockHeight</code> corresponds to the
height of the snapshot.</p>

<p>This verification ensures that an application is valid before joining the network. However, the
snapshot restoration may take a long time to complete, so applications may want to employ additional
verification during the restore to detect failures early. This might e.g. include incremental
verification of each chunk against the app hash (using bundled Merkle proofs), checksums to
protect against data corruption by the disk or network, and so on. However, it is important to
note that the only trusted information available is the app hash, and all other snapshot metadata
can be spoofed by adversaries.</p>

<p>Apps may also want to consider state sync denial-of-service vectors, where adversaries provide
invalid or harmful snapshots to prevent nodes from joining the network. The application can
counteract this by asking CometBFT to ban peers. As a last resort, node operators can use
P2P configuration options to whitelist a set of trusted peers that can provide valid snapshots.</p>

<h5 id="transition-to-consensus">Transition to Consensus</h5>

<p>Once the snapshots have all been restored, CometBFT gathers additional information necessary for
bootstrapping the node (e.g. chain ID, consensus parameters, validator sets, and block headers)
from the genesis file and light client RPC servers. It also calls <code class="language-plaintext highlighter-rouge">Info</code> to verify the following:</p>

<ul>
  <li>that the app hash from the snapshot it has delivered to the Application matches the apphash
stored in the next height‚Äôs block</li>
  <li>that the version that the Application returns in <code class="language-plaintext highlighter-rouge">ResponseInfo</code> matches the version in the
current height‚Äôs block header</li>
</ul>

<p>Once the state machine has been restored and CometBFT has gathered this additional
information, it transitions to block sync (if enabled) to fetch any remaining blocks up the chain
head, and then transitions to regular consensus operation. At this point the node operates like
any other node, apart from having a truncated block history at the height of the restored snapshot.</p>
:ET