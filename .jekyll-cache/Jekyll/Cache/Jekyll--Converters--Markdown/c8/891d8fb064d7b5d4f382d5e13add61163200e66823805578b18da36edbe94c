I"<h1 id="bft-time">BFT Time</h1>

<p>CometBFT provides a deterministic, Byzantine fault-tolerant, source of time.
Time in CometBFT is defined with the Time field of the block header.</p>

<p>It satisfies the following properties:</p>

<ul>
  <li>Time Monotonicity: Time is monotonically increasing, i.e., given
a header H1 for height h1 and a header H2 for height <code class="language-plaintext highlighter-rouge">h2 = h1 + 1</code>, <code class="language-plaintext highlighter-rouge">H1.Time &lt; H2.Time</code>.</li>
  <li>Time Validity: Given a set of Commit votes that forms the <code class="language-plaintext highlighter-rouge">block.LastCommit</code> field, a range of
valid values for the Time field of the block header is defined only by<br />
Precommit messages (from the LastCommit field) sent by correct processes, i.e.,
a faulty process cannot arbitrarily increase the Time value.</li>
</ul>

<p>In the context of CometBFT, time is of type int64 and denotes UNIX time in milliseconds, i.e.,
corresponds to the number of milliseconds since January 1, 1970.
Before defining rules that need to be enforced by Tendermint, the consensus algorithm adopted in CometBFT,
so the properties above holds, we introduce the following definition:</p>

<ul>
  <li>median of a Commit is equal to the median of <code class="language-plaintext highlighter-rouge">Vote.Time</code> fields of the <code class="language-plaintext highlighter-rouge">Vote</code> messages,
where the value of <code class="language-plaintext highlighter-rouge">Vote.Time</code> is counted number of times proportional to the process voting power. As
the voting power is not uniform (one process one vote), a vote message is actually an aggregator of the same votes whose
number is equal to the voting power of the process that has casted the corresponding votes message.</li>
</ul>

<p>Let’s consider the following example:</p>

<ul>
  <li>we have four processes p1, p2, p3 and p4, with the following voting power distribution (p1, 23), (p2, 27), (p3, 10)
and (p4, 10). The total voting power is 70 (<code class="language-plaintext highlighter-rouge">N = 3f+1</code>, where <code class="language-plaintext highlighter-rouge">N</code> is the total voting power, and <code class="language-plaintext highlighter-rouge">f</code> is the maximum voting
power of the faulty processes), so we assume that the faulty processes have at most 23 of voting power.
Furthermore, we have the following vote messages in some LastCommit field (we ignore all fields except Time field):
    <ul>
      <li>(p1, 100), (p2, 98), (p3, 1000), (p4, 500). We assume that p3 and p4 are faulty processes. Let’s assume that the
<code class="language-plaintext highlighter-rouge">block.LastCommit</code> message contains votes of processes p2, p3 and p4. Median is then chosen the following way:
the value 98 is counted 27 times, the value 1000 is counted 10 times and the value 500 is counted also 10 times.
So the median value will be the value 98. No matter what set of messages with at least <code class="language-plaintext highlighter-rouge">2f+1</code> voting power we
choose, the median value will always be between the values sent by correct processes.</li>
    </ul>
  </li>
</ul>

<p>We ensure Time Monotonicity and Time Validity properties by the following rules:</p>

<ul>
  <li>
    <p>let rs denotes <code class="language-plaintext highlighter-rouge">RoundState</code> (consensus internal state) of some process. Then
<code class="language-plaintext highlighter-rouge">rs.ProposalBlock.Header.Time == median(rs.LastCommit) &amp;&amp;
rs.Proposal.Timestamp == rs.ProposalBlock.Header.Time</code>.</p>
  </li>
  <li>
    <p>Furthermore, when creating the <code class="language-plaintext highlighter-rouge">vote</code> message, the following rules for determining <code class="language-plaintext highlighter-rouge">vote.Time</code> field should hold:</p>

    <ul>
      <li>
        <p>if <code class="language-plaintext highlighter-rouge">rs.LockedBlock</code> is defined then
  <code class="language-plaintext highlighter-rouge">vote.Time = max(rs.LockedBlock.Timestamp + time.Millisecond, time.Now())</code>, where <code class="language-plaintext highlighter-rouge">time.Now()</code>
  denotes local Unix time in milliseconds</p>
      </li>
      <li>
        <p>else if <code class="language-plaintext highlighter-rouge">rs.Proposal</code> is defined then
  <code class="language-plaintext highlighter-rouge">vote.Time = max(rs.Proposal.Timestamp + time.Millisecond,, time.Now())</code>,</p>
      </li>
      <li>
        <p>otherwise, <code class="language-plaintext highlighter-rouge">vote.Time = time.Now())</code>. In this case vote is for <code class="language-plaintext highlighter-rouge">nil</code> so it is not taken into account for
  the timestamp of the next block.</p>
      </li>
    </ul>
  </li>
</ul>
:ET