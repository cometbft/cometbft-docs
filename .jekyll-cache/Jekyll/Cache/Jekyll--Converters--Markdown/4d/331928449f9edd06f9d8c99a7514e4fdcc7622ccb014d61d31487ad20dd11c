I",l<h1 id="fork-accountability">Fork accountability</h1>

<h2 id="problem-statement">Problem Statement</h2>

<p>Tendermint consensus algorithm guarantees the following specifications for all heights:</p>

<ul>
  <li>agreement – no two correct full nodes decide differently.</li>
  <li>validity – the decided block satisfies the predefined predicate <em>valid()</em>.</li>
  <li>termination – all correct full nodes eventually decide,</li>
</ul>

<p>If the faulty validators have less than 1/3 of voting power in the current validator set. In the case where this assumption
does not hold, each of the specification may be violated.</p>

<p>The agreement property says that for a given height, any two correct validators that decide on a block for that height decide on the same block. That the block was indeed generated by the blockchain, can be verified starting from a trusted (genesis) block, and checking that all subsequent blocks are properly signed.</p>

<p>However, faulty nodes may forge blocks and try to convince users (light clients) that the blocks had been correctly generated. In addition, Tendermint agreement might be violated in the case where 1/3 or more of the voting power belongs to faulty validators: Two correct validators decide on different blocks. The latter case motivates the term “fork”: as Tendermint consensus also agrees on the next validator set, correct validators may have decided on disjoint next validator sets, and the chain branches into two or more partitions (possibly having faulty validators in common) and each branch continues to generate blocks independently of the other.</p>

<p>We say that a fork is a case in which there are two commits for different blocks at the same height of the blockchain. The problem is to ensure that in those cases we are able to detect faulty validators (and not mistakenly accuse correct validators), and incentivize therefore validators to behave according to the protocol specification.</p>

<p><strong>Conceptual Limit.</strong> In order to prove misbehavior of a node, we have to show that the behavior deviates from correct behavior with respect to a given algorithm. Thus, an algorithm that detects misbehavior of nodes executing some algorithm <em>A</em> must be defined with respect to algorithm <em>A</em>. In our case, <em>A</em> is Tendermint consensus (+ other protocols in the infrastructure; e.g., Cosmos full nodes and the Light Client). If the consensus algorithm is changed/updated/optimized in the future, we have to check whether changes to the accountability algorithm are also required. All the discussions in this document are thus inherently specific to Tendermint consensus and the Light Client specification.</p>

<p><strong>Q:</strong> Should we distinguish agreement for validators and full nodes for agreement? The case where all correct validators agree on a block, but a correct full node decides on a different block seems to be slightly less severe that the case where two correct validators decide on different blocks. Still, if a contaminated full node becomes validator that may be problematic later on. Also it is not clear how gossiping is impaired if a contaminated full node is on a different branch.</p>

<p><em>Remark.</em> In the case 1/3 or more of the voting power belongs to faulty validators, also validity and termination can be broken. Termination can be broken if faulty processes just do not send the messages that are needed to make progress. Due to asynchrony, this is not punishable, because faulty validators can always claim they never received the messages that would have forced them to send messages.</p>

<h2 id="the-misbehavior-of-faulty-validators">The Misbehavior of Faulty Validators</h2>

<p>Forks are the result of faulty validators deviating from the protocol. In principle several such deviations can be detected without a fork actually occurring:</p>

<ol>
  <li>
    <p>double proposal: A faulty proposer proposes two different values (blocks) for the same height and the same round in Tendermint consensus.</p>
  </li>
  <li>
    <p>double signing: Tendermint consensus forces correct validators to prevote and precommit for at most one value per round. In case a faulty validator sends multiple prevote and/or precommit messages for different values for the same height/round, this is a misbehavior.</p>
  </li>
  <li>
    <p>lunatic validator: Tendermint consensus forces correct validators to prevote and precommit only for values <em>v</em> that satisfy <em>valid(v)</em>. If faulty validators prevote and precommit for <em>v</em> although <em>valid(v)=false</em> this is misbehavior.</p>
  </li>
</ol>

<p><em>Remark.</em> In isolation, Point 3 is an attack on validity (rather than agreement). However, the prevotes and precommits can then also be used to forge blocks.</p>

<ol>
  <li>
    <p>amnesia: Tendermint consensus has a locking mechanism. If a validator has some value v locked, then it can only prevote/precommit for v or nil. Sending prevote/precomit message for a different value v’ (that is not nil) while holding lock on value v is misbehavior.</p>
  </li>
  <li>
    <p>spurious messages: In Tendermint consensus most of the message send instructions are guarded by threshold guards, e.g., one needs to receive <em>2f + 1</em> prevote messages to send precommit. Faulty validators may send precommit without having received the prevote messages.</p>
  </li>
</ol>

<p>Independently of a fork happening, punishing this behavior might be important to prevent forks altogether. This should keep attackers from misbehaving: if less than 1/3 of the voting power is faulty, this misbehavior is detectable but will not lead to a safety violation. Thus, unless they have 1/3 or more (or in some cases more than 2/3) of the voting power attackers have the incentive to not misbehave. If attackers control too much voting power, we have to deal with forks, as discussed in this document.</p>

<h2 id="two-types-of-forks">Two types of forks</h2>

<ul>
  <li>Fork-Full. Two correct validators decide on different blocks for the same height. Since also the next validator sets are decided upon, the correct validators may be partitioned to participate in two distinct branches of the forked chain.</li>
</ul>

<p>As in this case we have two different blocks (both having the same right/no right to exist), a central system invariant (one block per height decided by correct validators) is violated. As full nodes are contaminated in this case, the contamination can spread also to light clients. However, even without breaking this system invariant, light clients can be subject to a fork:</p>

<ul>
  <li>Fork-Light. All correct validators decide on the same block for height <em>h</em>, but faulty processes (validators or not), forge a different block for that height, in order to fool users (who use the light client).</li>
</ul>

<h1 id="attack-scenarios">Attack scenarios</h1>

<h2 id="on-chain-attacks">On-chain attacks</h2>

<h3 id="equivocation-one-round">Equivocation (one round)</h3>

<p>There are several scenarios in which forks might happen. The first is double signing within a round.</p>

<ul>
  <li>F1. Equivocation: faulty validators sign multiple vote messages (prevote and/or precommit) for different values <em>during the same round r</em> at a given height h.</li>
</ul>

<h3 id="flip-flopping">Flip-flopping</h3>

<p>Tendermint consensus implements a locking mechanism: If a correct validator <em>p</em> receives proposal for value v and <em>2f + 1</em> prevotes for a value <em>id(v)</em> in round <em>r</em>, it locks <em>v</em> and remembers <em>r</em>. In this case, <em>p</em> also sends a precommit message for <em>id(v)</em>, which later may serve as proof that <em>p</em> locked <em>v</em>.
In subsequent rounds, <em>p</em> only sends prevote messages for a value it had previously locked. However, it is possible to change the locked value if in a future round <em>r’ &gt; r</em>, if the process receives proposal and <em>2f + 1</em> prevotes for a different value <em>v’</em>. In this case, <em>p</em> could send a prevote/precommit for <em>id(v’)</em>. This algorithmic feature can be exploited in two ways:</p>

<ul>
  <li>
    <p>F2. Faulty Flip-flopping (Amnesia): faulty validators precommit some value <em>id(v)</em> in round <em>r</em> (value <em>v</em> is locked in round <em>r</em>) and then prevote for different value <em>id(v’)</em> in higher round <em>r’ &gt; r</em> without previously correctly unlocking value <em>v</em>. In this case faulty processes “forget” that they have locked value <em>v</em> and prevote some other value in the following rounds.
Some correct validators might have decided on <em>v</em> in <em>r</em>, and other correct validators decide on <em>v’</em> in <em>r’</em>. Here we can have branching on the main chain (Fork-Full).</p>
  </li>
  <li>
    <p>F3. Correct Flip-flopping (Back to the past): There are some precommit messages signed by (correct) validators for value <em>id(v)</em> in  round <em>r</em>. Still, <em>v</em> is not decided upon, and all processes move on to the next round. Then correct validators (correctly) lock and decide a different value <em>v’</em> in some round <em>r’ &gt; r</em>. And the correct validators continue; there is no branching on the main chain.
However, faulty validators may use the correct precommit messages from round <em>r</em> together with a posteriori generated faulty precommit messages for round <em>r</em> to forge a block for a value that was not decided on the main chain (Fork-Light).</p>
  </li>
</ul>

<h2 id="off-chain-attacks">Off-chain attacks</h2>

<p>F1-F3 may contaminate the state of full nodes (and even validators). Contaminated (but otherwise correct) full nodes may thus communicate faulty blocks to light clients.
Similarly, without actually interfering with the main chain, we can have the following:</p>

<ul>
  <li>
    <p>F4. Phantom validators: faulty validators vote (sign prevote and precommit messages) in heights in which they are not part of the validator sets (at the main chain).</p>
  </li>
  <li>
    <p>F5. Lunatic validator: faulty validator that sign vote messages to support (arbitrary) application state that is different from the application state that resulted from valid state transitions.</p>
  </li>
</ul>

<h2 id="types-of-victims">Types of victims</h2>

<p>We consider three types of potential attack victims:</p>

<ul>
  <li>FN: full node</li>
  <li>LCS: light client with sequential header verification</li>
  <li>LCB: light client with bisection based header verification</li>
</ul>

<p>F1 and F2 can be used by faulty validators to actually create multiple branches on the blockchain. That means that correctly operating full nodes decide on different blocks for the same height. Until a fork is detected locally by a full node (by receiving evidence from others or by some other local check that fails), the full node can spread corrupted blocks to light clients.</p>

<p><em>Remark.</em> If full nodes take a branch different from the one taken by the validators, it may be that the liveness of the gossip protocol may be affected. We should eventually look at this more closely. However, as it does not influence safety it is not a primary concern.</p>

<p>F3 is similar to F1, except that no two correct validators decide on different blocks. It may still be the case that full nodes become affected.</p>

<p>In addition, without creating a fork on the main chain, light clients can be contaminated by more than a third of validators that are faulty and sign a forged header
F4 cannot fool correct full nodes as they know the current validator set. Similarly, LCS know who the validators are. Hence, F4 is an attack against LCB that do not necessarily know the complete prefix of headers (Fork-Light), as they trust a header that is signed by at least one correct validator (trusting period method).</p>

<p>The following table gives an overview of how the different attacks may affect different nodes. F1-F3 are <em>on-chain</em> attacks so they can corrupt the state of full nodes. Then if a light client (LCS or LCB) contacts a full node to obtain headers (or blocks), the corrupted state may propagate to the light client.</p>

<p>F4 and F5 are <em>off-chain</em>, that is, these attacks cannot be used to corrupt the state of full nodes (which have sufficient knowledge on the state of the chain to not be fooled).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Attack</th>
      <th style="text-align: center">FN</th>
      <th style="text-align: center">LCS</th>
      <th style="text-align: center">LCB</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">F1</td>
      <td style="text-align: center">direct</td>
      <td style="text-align: center">FN</td>
      <td style="text-align: center">FN</td>
    </tr>
    <tr>
      <td style="text-align: center">F2</td>
      <td style="text-align: center">direct</td>
      <td style="text-align: center">FN</td>
      <td style="text-align: center">FN</td>
    </tr>
    <tr>
      <td style="text-align: center">F3</td>
      <td style="text-align: center">direct</td>
      <td style="text-align: center">FN</td>
      <td style="text-align: center">FN</td>
    </tr>
    <tr>
      <td style="text-align: center">F4</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">direct</td>
    </tr>
    <tr>
      <td style="text-align: center">F5</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">direct</td>
    </tr>
  </tbody>
</table>

<p><strong>Q:</strong> Light clients are more vulnerable than full nodes, because the former do only verify headers but do not execute transactions. What kind of certainty is gained by a full node that executes a transaction?</p>

<p>As a full node verifies all transactions, it can only be
contaminated by an attack if the blockchain itself violates its invariant (one block per height), that is, in case of a fork that leads to branching.</p>

<h2 id="detailed-attack-scenarios">Detailed Attack Scenarios</h2>

<h3 id="equivocation-based-attacks">Equivocation based attacks</h3>

<p>In case of equivocation based attacks, faulty validators sign multiple votes (prevote and/or precommit) in the same
round of some height. This attack can be executed on both full nodes and light clients. It requires 1/3 or more of voting power to be executed.</p>

<h4 id="scenario-1-equivocation-on-the-main-chain">Scenario 1: Equivocation on the main chain</h4>

<p>Validators:</p>

<ul>
  <li>CA - a set of correct validators with less than 1/3 of the voting power</li>
  <li>CB - a set of correct validators with less than 1/3 of the voting power</li>
  <li>CA and CB are disjoint</li>
  <li>F - a set of faulty validators with 1/3 or more voting power</li>
</ul>

<p>Observe that this setting violates the Cosmos failure model.</p>

<p>Execution:</p>

<ul>
  <li>A faulty proposer proposes block A to CA</li>
  <li>A faulty proposer proposes block B to CB</li>
  <li>Validators from the set CA and CB prevote for A and B, respectively.</li>
  <li>Faulty validators from the set F prevote both for A and B.</li>
  <li>The faulty prevote messages
    <ul>
      <li>for A arrive at CA long before the B messages</li>
      <li>for B arrive at CB long before the A messages</li>
    </ul>
  </li>
  <li>Therefore correct validators from set CA and CB will observe
more than 2/3 of prevotes for A and B and precommit for A and B, respectively.</li>
  <li>Faulty validators from the set F precommit both values A and B.</li>
  <li>Thus, we have more than 2/3 commits for both A and B.</li>
</ul>

<p>Consequences:</p>

<ul>
  <li>
    <p>Creating evidence of misbehavior is simple in this case as we have multiple messages signed by the same faulty processes for different values in the same round.</p>
  </li>
  <li>
    <p>We have to ensure that these different messages reach a correct process (full node, monitor?), which can submit evidence.</p>
  </li>
  <li>This is an attack on the full node level (Fork-Full).</li>
  <li>It extends also to the light clients,</li>
  <li>For both we need a detection and recovery mechanism.</li>
</ul>

<h4 id="scenario-2-equivocation-to-a-light-client-lcs">Scenario 2: Equivocation to a light client (LCS)</h4>

<p>Validators:</p>

<ul>
  <li>a set F of faulty validators with more than 2/3 of the voting power.</li>
</ul>

<p>Execution:</p>

<ul>
  <li>for the main chain F behaves nicely</li>
  <li>F coordinates to sign a block B that is different from the one on the main chain.</li>
  <li>the light clients obtains B and trusts at as it is signed by more than 2/3 of the voting power.</li>
</ul>

<p>Consequences:</p>

<p>Once equivocation is used to attack light client it opens space
for different kind of attacks as application state can be diverged in any direction. For example, it can modify validator set such that it contains only validators that do not have any stake bonded. Note that after a light client is fooled by a fork, that means that an attacker can change application state and validator set arbitrarily.</p>

<p>In order to detect such (equivocation-based attack), the light client would need to cross check its state with some correct validator (or to obtain a hash of the state from the main chain using out of band channels).</p>

<p><em>Remark.</em> The light client would be able to create evidence of misbehavior, but this would require to pull potentially a lot of data from correct full nodes. Maybe we need to figure out different architecture where a light client that is attacked will push all its data for the current unbonding period to a correct node that will inspect this data and submit corresponding evidence. There are also architectures that assumes a special role (sometimes called fisherman) whose goal is to collect as much as possible useful data from the network, to do analysis and create evidence transactions. That functionality is outside the scope of this document.</p>

<p><em>Remark.</em> The difference between LCS and LCB might only be in the amount of voting power needed to convince light client about arbitrary state. In case of LCB where security threshold is at minimum, an attacker can arbitrarily modify application state with 1/3 or more of voting power, while in case of LCS it requires more than 2/3 of the voting power.</p>

<h3 id="flip-flopping-amnesia-based-attacks">Flip-flopping: Amnesia based attacks</h3>

<p>In case of amnesia, faulty validators lock some value <em>v</em> in some round <em>r</em>, and then vote for different value <em>v’</em> in higher rounds without correctly unlocking value <em>v</em>. This attack can be used both on full nodes and light clients.</p>

<h4 id="scenario-3-at-most-23-of-faults">Scenario 3: At most 2/3 of faults</h4>

<p>Validators:</p>

<ul>
  <li>a set F of faulty validators with 1/3 or more but at most 2/3 of the voting power</li>
  <li>a set C of correct validators</li>
</ul>

<p>Execution:</p>

<ul>
  <li>Faulty validators commit (without exposing it on the main chain) a block A in round <em>r</em> by collecting more than 2/3 of the
voting power (containing correct and faulty validators).</li>
  <li>All validators (correct and faulty) reach a round <em>r’ &gt; r</em>.</li>
  <li>Some correct validators in C do not lock any value before round <em>r’</em>.</li>
  <li>The faulty validators in F deviate from Tendermint consensus by ignoring that they locked A in <em>r</em>, and propose a different block B in <em>r’</em>.</li>
  <li>As the validators in C that have not locked any value find B acceptable, they accept the proposal for B and commit a block B.</li>
</ul>

<p><em>Remark.</em> In this case, the more than 1/3 of faulty validators do not need to commit an equivocation (F1) as they only vote once per round in the execution.</p>

<p>Detecting faulty validators in the case of such an attack can be done by the fork accountability mechanism described in:
<!-- markdown-link-check-disable-next-line -->
<a href="https://docs.google.com/document/d/11ZhMsCj3y7zIZz4udO9l25xqb0kl7gmWqNpGVRzOeyY/edit?usp=sharing">https://docs.google.com/document/d/11ZhMsCj3y7zIZz4udO9l25xqb0kl7gmWqNpGVRzOeyY/edit?usp=sharing</a>.</p>

<p>If a light client is attacked using this attack with 1/3 or more of voting power (and less than 2/3), the attacker cannot change the application state arbitrarily. Rather, the attacker is limited to a state a correct validator finds acceptable: In the execution above, correct validators still find the value acceptable, however, the block the light client trusts deviates from the one on the main chain.</p>

<h4 id="scenario-4-more-than-23-of-faults">Scenario 4: More than 2/3 of faults</h4>

<p>In case there is an attack with more than 2/3 of the voting power, an attacker can arbitrarily change application state.</p>

<p>Validators:</p>

<ul>
  <li>a set F1 of faulty validators with 1/3 or more of the voting power</li>
  <li>a set F2 of faulty validators with less than 1/3 of the voting power</li>
</ul>

<p>Execution</p>

<ul>
  <li>Similar to Scenario 3 (however, messages by correct validators are not needed)</li>
  <li>The faulty validators in F1 lock value A in round <em>r</em></li>
  <li>They sign a different value in follow-up rounds</li>
  <li>F2 does not lock A in round <em>r</em></li>
</ul>

<p>Consequences:</p>

<ul>
  <li>The validators in F1 will be detectable by the the fork accountability mechanisms.</li>
  <li>The validators in F2 cannot be detected using this mechanism.
Only in case they signed something which conflicts with the application this can be used against them. Otherwise they do not do anything incorrect. <!-- markdown-link-check-disable-next-line --></li>
  <li>This case is not covered by the report <a href="https://docs.google.com/document/d/11ZhMsCj3y7zIZz4udO9l25xqb0kl7gmWqNpGVRzOeyY/edit?usp=sharing">https://docs.google.com/document/d/11ZhMsCj3y7zIZz4udO9l25xqb0kl7gmWqNpGVRzOeyY/edit?usp=sharing</a> as it only assumes at most 2/3 of faulty validators.</li>
</ul>

<p><strong>Q:</strong> do we need to define a special kind of attack for the case where a validator sign arbitrarily state? It seems that detecting such attack requires a different mechanism that would require as an evidence a sequence of blocks that led to that state. This might be very tricky to implement.</p>

<h3 id="back-to-the-past">Back to the past</h3>

<p>In this kind of attack, faulty validators take advantage of the fact that they did not sign messages in some of the past rounds. Due to the asynchronous network in which Tendermint operates, we cannot easily differentiate between such an attack and delayed message. This kind of attack can be used at both full nodes and light clients.</p>

<h4 id="scenario-5">Scenario 5</h4>

<p>Validators:</p>

<ul>
  <li>C1 -  a set of correct validators with over 1/3 of the voting power</li>
  <li>C2 - a set of correct validators with 1/3 of the voting power</li>
  <li>C1 and C2 are disjoint</li>
  <li>F - a set of faulty validators with less than 1/3 voting power</li>
  <li>one additional faulty process <em>q</em></li>
  <li>F and <em>q</em> violate the Cosmos failure model.</li>
</ul>

<p>Execution:</p>

<ul>
  <li>in a round <em>r</em> of height <em>h</em> we have C1 precommitting a value A,</li>
  <li>C2 precommits nil,</li>
  <li>F does not send any message</li>
  <li><em>q</em> precommits nil.</li>
  <li>In some round <em>r’ &gt; r</em>, F and <em>q</em> and C2 commit some other value B different from A.</li>
  <li>F and <em>fp</em> “go back to the past” and sign precommit message for value A in round <em>r</em>.</li>
  <li>Together with precomit messages of C1 this is sufficient for a commit for value A.</li>
</ul>

<p>Consequences:</p>

<ul>
  <li>Only a single faulty validator that previously precommited nil did equivocation, while the other 1/3 of faulty validators actually executed an attack that has exactly the same sequence of messages as part of amnesia attack. Detecting this kind of attack boil down to mechanisms for equivocation and amnesia.</li>
</ul>

<p><strong>Q:</strong> should we keep this as a separate kind of attack? It seems that equivocation, amnesia and phantom validators are the only kind of attack we need to support and this gives us security also in other cases. This would not be surprising as equivocation and amnesia are attacks that followed from the protocol and phantom attack is not really an attack to Tendermint but more to the Cosmos Proof of Stake module.</p>

<h3 id="phantom-validators">Phantom validators</h3>

<p>In case of phantom validators, processes that are not part of the current validator set but are still bonded (as attack happen during their unbonding period) can be part of the attack by signing vote messages. This attack can be executed against both full nodes and light clients.</p>

<h4 id="scenario-6">Scenario 6</h4>

<p>Validators:</p>

<ul>
  <li>F – a set of faulty validators that are not part of the validator set on the main chain at height <em>h + k</em></li>
</ul>

<p>Execution:</p>

<ul>
  <li>There is a fork, and there exist two different headers for height <em>h + k</em>, with different validator sets:
    <ul>
      <li>VS2 on the main chain</li>
      <li>forged header VS2’, signed by F (and others)</li>
    </ul>
  </li>
  <li>a light client has a trust in a header for height <em>h</em> (and the corresponding validator set VS1).</li>
  <li>As part of bisection header verification, it verifies the header at height <em>h + k</em> with new validator set VS2’.</li>
</ul>

<p>Consequences:</p>

<ul>
  <li>To detect this, a node needs to see both, the forged header and the canonical header from the chain.</li>
  <li>If this is the case, detecting these kind of attacks is easy as it just requires verifying if processes are signing messages in heights in which they are not part of the validator set.</li>
</ul>

<p><strong>Remark.</strong> We can have phantom-validator-based attacks as a follow up of equivocation or amnesia based attack where forked state contains validators that are not part of the validator set at the main chain. In this case, they keep signing messages contributed to a forked chain (the wrong branch) although they are not part of the validator set on the main chain. This attack can also be used to attack full node during a period of time it is eclipsed.</p>

<p><strong>Remark.</strong> Phantom validator evidence has been removed from implementation as it was deemed, although possibly a plausible form of evidence, not relevant. Any attack on
the light client involving a phantom validator will have needed to be initiated by 1/3+ lunatic
validators that can forge a new validator set that includes the phantom validator. Only in
that case will the light client accept the phantom validators vote. We need only worry about
punishing the 1/3+ lunatic cabal, that is the root cause of the attack.</p>

<h3 id="lunatic-validator">Lunatic validator</h3>

<p>Lunatic validator agrees to sign commit messages for arbitrary application state. It is used to attack light clients.
Note that detecting this behavior require application knowledge. Detecting this behavior can probably be done by
referring to the block before the one in which height happen.</p>

<p><strong>Q:</strong> can we say that in this case a validator declines to check if a proposed value is valid before voting for it?</p>
:ET