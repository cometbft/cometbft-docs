I"‡ï<h2 id="outline">Outline</h2>

<ul>
  <li><a href="#overview-and-basic-concepts">Overview and basic concepts</a>
    <ul>
      <li><a href="#abci-vs-abci">ABCI++ vs. ABCI</a></li>
      <li><a href="#method-overview">Method overview</a>
        <ul>
          <li><a href="#consensusblock-execution-methods">Consensus/block execution methods</a></li>
          <li><a href="#mempool-methods">Mempool methods</a></li>
          <li><a href="#info-methods">Info methods</a></li>
          <li><a href="#state-sync-methods">State-sync methods</a></li>
          <li><a href="#other-methods">Other methods</a></li>
        </ul>
      </li>
      <li><a href="#proposal-timeout">Proposal timeout</a></li>
      <li><a href="#deterministic-state-machine-replication">Deterministic State-Machine Replication</a></li>
      <li><a href="#events">Events</a></li>
      <li><a href="#evidence">Evidence</a></li>
      <li><a href="#errors">Errors</a>
        <ul>
          <li><a href="#checktx"><code class="language-plaintext highlighter-rouge">CheckTx</code></a></li>
          <li><a href="#delivertx"><code class="language-plaintext highlighter-rouge">DeliverTx</code></a></li>
          <li><a href="#query"><code class="language-plaintext highlighter-rouge">Query</code></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="overview-and-basic-concepts">Overview and basic concepts</h1>

<h2 id="abci-vs-abci">ABCI++ vs. ABCI</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>The Application‚Äôs main role is to execute blocks decided (a.k.a. finalized) by consensus. The
decided blocks are the consensus‚Äôs main ouput to the (replicated) Application. With ABCI, the
application only interacts with consensus at <em>decision</em> time. This restricted mode of interaction
prevents numerous features for the Application, including many scalability improvements that are
now better understood than when ABCI was first written. For example, many ideas proposed to improve
scalability can be boiled down to ‚Äúmake the block proposers do work, so the network does not have
to‚Äù. This includes optimizations such as transaction level signature aggregation, state transition
proofs, etc. Furthermore, many new security properties cannot be achieved in the current paradigm,
as the Application cannot require validators to do more than executing the transactions contained in
finalized blocks. This includes features such as threshold cryptography, and guaranteed IBC
connection attempts.</p>

<p>ABCI++ addresses these limitations by allowing the application to intervene at two key places of
consensus execution: (a) at the moment a new proposal is to be created and (b) at the moment a
proposal is to be validated. The new interface allows block proposers to perform application-dependent
work in a block through the <code class="language-plaintext highlighter-rouge">PrepareProposal</code> method (a); and validators to perform application-dependent work
and checks in a proposed block through the <code class="language-plaintext highlighter-rouge">ProcessProposal</code> method (b).</p>

<!-- Furthermore, ABCI++ coalesces {`BeginBlock`, [`DeliverTx`], `EndBlock`} into `FinalizeBlock`, as a
simplified, efficient way to deliver a decided block to the Application. -->

<p>We plan to extend this to allow applications to intervene at the moment a (precommit) vote is sent/received.
The applications could then require their validators to do more than just validating blocks through the <code class="language-plaintext highlighter-rouge">ExtendVote</code>
and <code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code> methods.</p>

<h2 id="method-overview">Method overview</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>Methods can be classified into four categories: <em>consensus</em>, <em>mempool</em>, <em>info</em>, and <em>state-sync</em>.</p>

<h3 id="consensusblock-execution-methods">Consensus/block execution methods</h3>

<p>The first time a new blockchain is started, CometBFT calls <code class="language-plaintext highlighter-rouge">InitChain</code>. From then on, methods <code class="language-plaintext highlighter-rouge">BeginBlock</code>,
 <code class="language-plaintext highlighter-rouge">DeliverTx</code> and <code class="language-plaintext highlighter-rouge">EndBlock</code> are executed upon the decision of each block, resulting in an updated Application
state. One <code class="language-plaintext highlighter-rouge">DeliverTx</code> is called for each transaction in the block. The result is an updated application state.
Cryptographic commitments to the results of <code class="language-plaintext highlighter-rouge">DeliverTx</code>, and an application-provided hash in <code class="language-plaintext highlighter-rouge">Commit</code> are included in the header of the next block. During the execution of an instance of consensus, which decides the block for a given
height, and before method <code class="language-plaintext highlighter-rouge">BeginBlock</code> is called, methods <code class="language-plaintext highlighter-rouge">PrepareProposal</code> and <code class="language-plaintext highlighter-rouge">ProcessProposal</code>,
 may be called several times. See
<a href="/v0.37/spec/abci/abci++_tmint_expected_behavior/">CometBFT‚Äôs expected behavior</a> for details on the possible
call sequences of these methods.</p>

<ul>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#initchain"><strong>InitChain:</strong></a> This method initializes the blockchain.
CometBFT calls it once upon genesis.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#prepareproposal"><strong>PrepareProposal:</strong></a> It allows the block
proposer to perform application-dependent work in a block before proposing it.
This enables, for instance, batch optimizations to a block, which has been empirically
demonstrated to be a key component for improved performance. Method <code class="language-plaintext highlighter-rouge">PrepareProposal</code> is called
every time CometBFT is about to broadcast a Proposal message, but no previous proposal has
been locked at consensus level. CometBFT gathers outstanding transactions from the
mempool, generates a block header, and uses them to create a block to propose. Then, it calls
<code class="language-plaintext highlighter-rouge">RequestPrepareProposal</code> with the newly created proposal, called <em>raw proposal</em>. The Application
can make changes to the raw proposal, such as modifying the set of transactions or the order
in which they appear, and returns the
(potentially) modified proposal, called <em>prepared proposal</em> in the <code class="language-plaintext highlighter-rouge">ResponsePrepareProposal</code>
call. The logic modifying the raw proposal can be non-deterministic.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#processproposal"><strong>ProcessProposal:</strong></a> It allows a validator to
perform application-dependent work in a proposed block. This enables features such as immediate
block execution, and allows the Application to reject invalid blocks.
CometBFT calls it when it receives a proposal and the consensus algorithm has not locked on a
value. The Application cannot modify the proposal at this point but can reject it if it is
invalid. If that is the case, the consensus algorithm will prevote <code class="language-plaintext highlighter-rouge">nil</code> on the proposal, which has
strong liveness implications for CometBFT. As a general rule, the Application
SHOULD accept a prepared proposal passed via <code class="language-plaintext highlighter-rouge">ProcessProposal</code>, even if a part of
the proposal is invalid (e.g., an invalid transaction); the Application can
ignore the invalid part of the prepared proposal at block execution time.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#beginblock"><strong>BeginBlock:</strong></a> Is called exactly once after a block has been decided
and executes once before all <code class="language-plaintext highlighter-rouge">DeliverTx</code> method calls.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#delivertx"><strong>DeliverTx</strong></a> Upon completion of <code class="language-plaintext highlighter-rouge">BeginBlock</code>,
<code class="language-plaintext highlighter-rouge">DeliverTx</code> is called once
for each of the transactions within the block. The application defines further checks to confirm their
validity - for example a key-value store might verify that the key does not already exist. Note that
even if a transaction does not pass the check in <code class="language-plaintext highlighter-rouge">DeliverTx</code>, it will still be part of the block as the
block has already been voted on (unlike with <code class="language-plaintext highlighter-rouge">CheckTx</code> which would dismiss such a transaction). The responses
returned by <code class="language-plaintext highlighter-rouge">DeliverTx</code> are included in the header of the next block.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#endblock"><strong>EndBlock</strong></a> It is executed once all transactions have been processed via
 <code class="language-plaintext highlighter-rouge">DeliverTx</code> to inform the application that no other transactions will be delivered as part of the current
 block and to ask for changes of the validator set and consensus parameters to be used in the following block.
 As with <code class="language-plaintext highlighter-rouge">DeliverTx</code>, cryptographic commitments of the responses returned are included in the header of the next block.
&lt;!‚Äì</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#extendvote"><strong>ExtendVote:</strong></a> It allows applications to force their
validators to do more than just validate within consensus. <code class="language-plaintext highlighter-rouge">ExtendVote</code> allows applications to
include non-deterministic data, opaque to the consensus algorithm, to precommit messages (the final round of
voting). The data, called <em>vote extension</em>, will be broadcast and received together with the
vote it is extending, and will be made available to the Application in the next height,
in the rounds where the local process is the proposer.
CometBFT calls <code class="language-plaintext highlighter-rouge">ExtendVote</code> when the consensus algorithm is about to send a non-<code class="language-plaintext highlighter-rouge">nil</code> precommit message.
If the Application does not have vote extension information to provide at that time, it returns
a 0-length byte array as its vote extension.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#verifyvoteextension"><strong>VerifyVoteExtension:</strong></a> It allows
validators to validate the vote extension data attached to a precommit message. If the validation
fails, the whole precommit message will be deemed invalid and ignored by consensus algorithm.
This has a negative impact on liveness, i.e., if vote extensions repeatedly cannot be
verified by correct validators, the consensus algorithm may not be able to finalize a block even if sufficiently
many (+2/3) validators send precommit votes for that block. Thus, <code class="language-plaintext highlighter-rouge">VerifyVoteExtension</code>
should be used with special care.
As a general rule, an Application that detects an invalid vote extension SHOULD
accept it in <code class="language-plaintext highlighter-rouge">ResponseVerifyVoteExtension</code> and ignore it in its own logic. CometBFT calls it when
a process receives a precommit message with a (possibly empty) vote extension.
‚Äì&gt;</p>
  </li>
</ul>

<!--- 
- [**FinalizeBlock:**](/v0.37/spec/abci/abci++_methods/#finalizeblock) It delivers a decided block to the
  Application. The Application must execute the transactions in the block deterministically and
  update its state accordingly. Cryptographic commitments to the block and transaction results,
  returned via the corresponding parameters in `ResponseFinalizeBlock`, are included in the header
  of the next block. CometBFT calls it when a new block is decided.
-->
<ul>
  <li><a href="/v0.37/spec/abci/abci++_methods/#commit"><strong>Commit:</strong></a> Instructs the Application to persist its
state. It is a fundamental part of CometBFT‚Äôs crash-recovery mechanism that ensures the
synchronization between CometBFT and the Applicatin upon recovery. CometBFT calls it just after
having persisted the data returned by calls to <code class="language-plaintext highlighter-rouge">DeliverTx</code> and <code class="language-plaintext highlighter-rouge">EndBlock</code> . The Application can now discard
any state or data except the one resulting from executing the transactions in the decided block.</li>
</ul>

<h3 id="mempool-methods">Mempool methods</h3>

<ul>
  <li><a href="/v0.37/spec/abci/abci++_methods/#checktx"><strong>CheckTx:</strong></a> This method allows the Application to validate
transactions. Validation can be stateless (e.g., checking signatures ) or stateful
(e.g., account balances). The type of validation performed is up to the application. If a
transaction passes the validation, then CometBFT adds it to the mempool; otherwise the
transaction is discarded.
CometBFT calls it when it receives a new transaction either coming from an external
user (e.g., a client) or another node. Furthermore, CometBFT can be configured to call
re-<code class="language-plaintext highlighter-rouge">CheckTx</code> on all outstanding transactions in the mempool after calling <code class="language-plaintext highlighter-rouge">Commit</code> for a block.</li>
</ul>

<h3 id="info-methods">Info methods</h3>

<ul>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#info"><strong>Info:</strong></a> Used to sync CometBFT with the Application during a
handshake that happens upon recovery, or on startup when state-sync is used.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#query"><strong>Query:</strong></a> This method can be used to query the Application for
information about the application state.</p>
  </li>
</ul>

<h3 id="state-sync-methods">State-sync methods</h3>

<p>State sync allows new nodes to rapidly bootstrap by discovering, fetching, and applying
state machine (application) snapshots instead of replaying historical blocks. For more details, see the
<a href="/v0.37/spec/p2p/messages/state-sync/">state sync documentation</a>.</p>

<p>New nodes discover and request snapshots from other nodes in the P2P network.
A CometBFT node that receives a request for snapshots from a peer will call
<code class="language-plaintext highlighter-rouge">ListSnapshots</code> on its Application. The Application returns the list of locally available
snapshots.
Note that the list does not contain the actual snapshots but metadata about them: height at which
the snapshot was taken, application-specific verification data and more (see
<a href="/v0.37/spec/abci/abci++_methods/#snapshot">snapshot data type</a> for more details). After receiving a
list of available snapshots from a peer, the new node can offer any of the snapshots in the list to
its local Application via the <code class="language-plaintext highlighter-rouge">OfferSnapshot</code> method. The Application can check at this point the
validity of the snapshot metadata.</p>

<p>Snapshots may be quite large and are thus broken into smaller ‚Äúchunks‚Äù that can be
assembled into the whole snapshot. Once the Application accepts a snapshot and
begins restoring it, CometBFT will fetch snapshot ‚Äúchunks‚Äù from existing nodes.
The node providing ‚Äúchunks‚Äù will fetch them from its local Application using
the <code class="language-plaintext highlighter-rouge">LoadSnapshotChunk</code> method.</p>

<p>As the new node receives ‚Äúchunks‚Äù it will apply them sequentially to the local
application with <code class="language-plaintext highlighter-rouge">ApplySnapshotChunk</code>. When all chunks have been applied, the
Application‚Äôs <code class="language-plaintext highlighter-rouge">AppHash</code> is retrieved via an <code class="language-plaintext highlighter-rouge">Info</code> query.
To ensure that the sync proceeded correctly, CometBFT compares the local Application‚Äôs <code class="language-plaintext highlighter-rouge">AppHash</code>
to the <code class="language-plaintext highlighter-rouge">AppHash</code> stored on the blockchain (verified via
<a href="/v0.37/spec/light-client/verification/README/">light client verification</a>).</p>

<p>In summary:</p>

<ul>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#listsnapshots"><strong>ListSnapshots:</strong></a> Used by nodes to discover available
snapshots on peers.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#offersnapshot"><strong>OfferSnapshot:</strong></a> When a node receives a snapshot from a
peer, CometBFT uses this method to offer the snapshot to the Application.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#loadsnapshotchunk"><strong>LoadSnapshotChunk:</strong></a> Used by CometBFT to retrieve
snapshot chunks from the Application to send to peers.</p>
  </li>
  <li>
    <p><a href="/v0.37/spec/abci/abci++_methods/#applysnapshotchunk"><strong>ApplySnapshotChunk:</strong></a> Used by CometBFT to hand
snapshot chunks to the Application.</p>
  </li>
</ul>

<h3 id="other-methods">Other methods</h3>

<p>Additionally, there is a <a href="/v0.37/spec/abci/abci++_methods/#flush"><strong>Flush</strong></a> method that is called on every connection,
and an <a href="/v0.37/spec/abci/abci++_methods/#echo"><strong>Echo</strong></a> method that is used for debugging.</p>

<p>More details on managing state across connections can be found in the section on
<a href="./abci%2B%2B_app_requirements.md#managing-the-application-state-and-related-topics">Managing Application State</a>.</p>

<h2 id="proposal-timeout">Proposal timeout</h2>

<p>Immediate execution requires the Application to fully execute the prepared block
before returning from <code class="language-plaintext highlighter-rouge">PrepareProposal</code>, this means that CometBFT cannot make progress
during the block execution.
This stands on the consensus algorithm critical path: if the Application takes a long time
executing the block, the default value of <em>TimeoutPropose</em> might not be sufficient
to accommodate the long block execution time and non-proposer nodes might time
out and prevote <code class="language-plaintext highlighter-rouge">nil</code>. The proposal, in this case, will probably be rejected and a new round will be necessary.</p>

<p>Operators will need to adjust the default value of <em>TimeoutPropose</em> in CometBFT‚Äôs configuration file,
in order to suit the needs of the particular application being deployed.</p>

<h2 id="deterministic-state-machine-replication">Deterministic State-Machine Replication</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>ABCI++ applications must implement deterministic finite-state machines to be
securely replicated by the CometBFT consensus engine. This means block execution
must be strictly deterministic: given the same
ordered set of transactions, all nodes will compute identical responses, for all
successive <code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">DeliverTx</code>, <code class="language-plaintext highlighter-rouge">EndBlock</code>, and <code class="language-plaintext highlighter-rouge">Commit</code> calls. This is critical because the
responses are included in the header of the next block, either via a Merkle root
or directly, so all nodes must agree on exactly what they are.</p>

<p>For this reason, it is recommended that application state is not exposed to any
external user or process except via the ABCI connections to a consensus engine
like CometBFT. The Application must only change its state based on input
from block execution (<code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">DeliverTx</code>, <code class="language-plaintext highlighter-rouge">EndBlock</code>, and <code class="language-plaintext highlighter-rouge">Commit</code> calls), and not through
any other kind of request. This is the only way to ensure all nodes see the same
transactions and compute the same results.</p>

<p>Some Applications may choose to implement immediate execution, which entails executing the blocks
that are about to be proposed (via <code class="language-plaintext highlighter-rouge">PrepareProposal</code>), and those that the Application is asked to
validate (via <code class="language-plaintext highlighter-rouge">ProcessProposal</code>). However, the state changes caused by processing those
proposed blocks must never replace the previous state until the block execution calls confirm
the block decided.</p>

<!--
Additionally, vote extensions or the validation thereof (via `ExtendVote` or
`VerifyVoteExtension`) must *never* have side effects on the current state.
They can only be used when their data is provided in a `RequestPrepareProposal` call.
-->
<p>If there is some non-determinism in the state machine, consensus will eventually
fail as nodes disagree over the correct values for the block header. The
non-determinism must be fixed and the nodes restarted.</p>

<p>Sources of non-determinism in applications may include:</p>

<ul>
  <li>Hardware failures
    <ul>
      <li>Cosmic rays, overheating, etc.</li>
    </ul>
  </li>
  <li>Node-dependent state
    <ul>
      <li>Random numbers</li>
      <li>Time</li>
    </ul>
  </li>
  <li>Underspecification
    <ul>
      <li>Library version changes</li>
      <li>Race conditions</li>
      <li>Floating point numbers</li>
      <li>JSON or protobuf serialization</li>
      <li>Iterating through hash-tables/maps/dictionaries</li>
    </ul>
  </li>
  <li>External Sources
    <ul>
      <li>Filesystem</li>
      <li>Network calls (eg. some external REST API service)</li>
    </ul>
  </li>
</ul>

<p>See <a href="https://github.com/tendermint/abci/issues/56">#56</a> for the original discussion.</p>

<p>Note that some methods (<code class="language-plaintext highlighter-rouge">Query, DeliverTx</code>) return non-deterministic data in the form
of <code class="language-plaintext highlighter-rouge">Info</code> and <code class="language-plaintext highlighter-rouge">Log</code> fields. The <code class="language-plaintext highlighter-rouge">Log</code> is intended for the literal output from the Application‚Äôs
logger, while the <code class="language-plaintext highlighter-rouge">Info</code> is any additional info that should be returned. These are the only fields
that are not included in block header computations, so we don‚Äôt need agreement
on them. All other fields in the <code class="language-plaintext highlighter-rouge">Response*</code> must be strictly deterministic.</p>

<h2 id="events">Events</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>Methods <code class="language-plaintext highlighter-rouge">BeginBlock, DeliverTx</code> and <code class="language-plaintext highlighter-rouge">EndBlock</code> include an <code class="language-plaintext highlighter-rouge">events</code> field in their
<code class="language-plaintext highlighter-rouge">Response*</code>.
Applications may respond to this ABCI++ method with an event list for each executed
transaction, and a general event list for the block itself.
Events allow applications to associate metadata with transactions and blocks.
Events returned via these ABCI methods do not impact the consensus algorithm in any way
and instead exist to power subscriptions and queries of CometBFT state.</p>

<p>An <code class="language-plaintext highlighter-rouge">Event</code> contains a <code class="language-plaintext highlighter-rouge">type</code> and a list of <code class="language-plaintext highlighter-rouge">EventAttributes</code>, which are key-value
string pairs denoting metadata about what happened during the method‚Äôs (or transaction‚Äôs)
execution. <code class="language-plaintext highlighter-rouge">Event</code> values can be used to index transactions and blocks according to what
happened during their execution.</p>

<p>Each event has a <code class="language-plaintext highlighter-rouge">type</code> which is meant to categorize the event for a particular
<code class="language-plaintext highlighter-rouge">Response*</code> or <code class="language-plaintext highlighter-rouge">Tx</code>. A <code class="language-plaintext highlighter-rouge">Response*</code> or <code class="language-plaintext highlighter-rouge">Tx</code> may contain multiple events with duplicate
<code class="language-plaintext highlighter-rouge">type</code> values, where each distinct entry is meant to categorize attributes for a
particular event. Every key and value in an event‚Äôs attributes must be UTF-8
encoded strings along with the event type itself.</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Event</span> <span class="p">{</span>
  <span class="kt">string</span>                  <span class="na">type</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">repeated</span> <span class="n">EventAttribute</span> <span class="na">attributes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The attributes of an <code class="language-plaintext highlighter-rouge">Event</code> consist of a <code class="language-plaintext highlighter-rouge">key</code>, a <code class="language-plaintext highlighter-rouge">value</code>, and an <code class="language-plaintext highlighter-rouge">index</code> flag. The
index flag notifies the CometBFT indexer to index the attribute. The value of
the <code class="language-plaintext highlighter-rouge">index</code> flag is non-deterministic and may vary across different nodes in the network.</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">EventAttribute</span> <span class="p">{</span>
  <span class="kt">string</span> <span class="na">key</span>   <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">string</span> <span class="na">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">bool</span>   <span class="na">index</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// nondeterministic</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Example:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">abci</span><span class="o">.</span><span class="n">ResponseDeliverTx</span><span class="p">{</span>
  <span class="c">// ...</span>
 <span class="n">Events</span><span class="o">:</span> <span class="p">[]</span><span class="n">abci</span><span class="o">.</span><span class="n">Event</span><span class="p">{</span>
  <span class="p">{</span>
   <span class="n">Type</span><span class="o">:</span> <span class="s">"validator.provisions"</span><span class="p">,</span>
   <span class="n">Attributes</span><span class="o">:</span> <span class="p">[]</span><span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"address"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"amount"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"balance"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
   <span class="p">},</span>
  <span class="p">},</span>
  <span class="p">{</span>
   <span class="n">Type</span><span class="o">:</span> <span class="s">"validator.provisions"</span><span class="p">,</span>
   <span class="n">Attributes</span><span class="o">:</span> <span class="p">[]</span><span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"address"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"amount"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">false</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"balance"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">false</span><span class="p">},</span>
   <span class="p">},</span>
  <span class="p">},</span>
  <span class="p">{</span>
   <span class="n">Type</span><span class="o">:</span> <span class="s">"validator.slashed"</span><span class="p">,</span>
   <span class="n">Attributes</span><span class="o">:</span> <span class="p">[]</span><span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"address"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">false</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"amount"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
    <span class="n">abci</span><span class="o">.</span><span class="n">EventAttribute</span><span class="p">{</span><span class="n">Key</span><span class="o">:</span> <span class="s">"reason"</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="s">"..."</span><span class="p">,</span> <span class="n">Index</span><span class="o">:</span> <span class="no">true</span><span class="p">},</span>
   <span class="p">},</span>
  <span class="p">},</span>
  <span class="c">// ...</span>
 <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="evidence">Evidence</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>CometBFT‚Äôs security model relies on the use of evidences of misbehavior. An evidence is an
irrefutable proof of malicious behavior by a network participant. It is the responsibility of
CometBFT to detect such malicious behavior. When malicious behavior is detected, CometBFT
will gossip evidences of misbehavior to other nodes and commit the evidences to
the chain once they are verified by a subset of validators. These evidences will then be
passed on to the Application through ABCI++. It is the responsibility of the
Application to handle evidence of misbehavior and exercise punishment.</p>

<p>There are two forms of evidence: Duplicate Vote and Light Client Attack. More
information can be found in either <a href="/v0.37/spec/core/data_structures.md">data structures</a>
or <a href="../light-client/accountability/">accountability</a>.</p>

<p>EvidenceType has the following protobuf format:</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="n">EvidenceType</span> <span class="p">{</span>
  <span class="na">UNKNOWN</span>               <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="na">DUPLICATE_VOTE</span>        <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="na">LIGHT_CLIENT_ATTACK</span>   <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="errors">Errors</h2>

<p><a href="#outline">&amp;uparrow; Back to Outline</a></p>

<p>The <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">CheckTx</code> and <code class="language-plaintext highlighter-rouge">DeliverTx</code> methods include a <code class="language-plaintext highlighter-rouge">Code</code> field in their <code class="language-plaintext highlighter-rouge">Response*</code>.
Field <code class="language-plaintext highlighter-rouge">Code</code> is meant to contain an application-specific response code.
A response code of <code class="language-plaintext highlighter-rouge">0</code> indicates no error.  Any other response code
indicates to CometBFT that an error occurred.</p>

<p>These methods also return a <code class="language-plaintext highlighter-rouge">Codespace</code> string to CometBFT. This field is
used to disambiguate <code class="language-plaintext highlighter-rouge">Code</code> values returned by different domains of the
Application. The <code class="language-plaintext highlighter-rouge">Codespace</code> is a namespace for the <code class="language-plaintext highlighter-rouge">Code</code>.</p>

<p>Methods <code class="language-plaintext highlighter-rouge">Echo</code>, <code class="language-plaintext highlighter-rouge">Info</code>, <code class="language-plaintext highlighter-rouge">BeginBlock</code>, <code class="language-plaintext highlighter-rouge">EndBlock</code>, <code class="language-plaintext highlighter-rouge">Commit</code> and <code class="language-plaintext highlighter-rouge">InitChain</code> do not return errors.
An error in any of these methods represents a critical issue that CometBFT
has no reasonable way to handle. If there is an error in one
of these methods, the Application must crash to ensure that the error is safely
handled by an operator.</p>

<!--
Method `FinalizeBlock` is a special case. It contains a number of
`Code` and `Codespace` fields as part of type `ExecTxResult`. Each of
these codes reports errors related to the transaction it is attached to.
However, `FinalizeBlock` does not return errors at the top level, so the
same considerations on critical issues made for `Echo`, `Info`, and
`InitChain` also apply here. 
-->

<p>The handling of non-zero response codes by CometBFT is described below.</p>

<h3 id="checktx"><code class="language-plaintext highlighter-rouge">CheckTx</code></h3>

<p>When CometBFT receives a <code class="language-plaintext highlighter-rouge">ResponseCheckTx</code> with a non-zero <code class="language-plaintext highlighter-rouge">Code</code>, the associated
transaction will not be added to CometBFT‚Äôs mempool or it will be removed if
it is already included.</p>

<h3 id="delivertx"><code class="language-plaintext highlighter-rouge">DeliverTx</code></h3>

<p>The <code class="language-plaintext highlighter-rouge">DeliverTx</code> ABCI method delivers transactions from CometBFT to the application.
When CometBFT receives a <code class="language-plaintext highlighter-rouge">ResponseDeliverTx</code> with a non-zero <code class="language-plaintext highlighter-rouge">Code</code>, the response code is logged.
The transaction was already included in a block, so the <code class="language-plaintext highlighter-rouge">Code</code> does not influence consensus.</p>

<!-- 
The `ExecTxResult` type delivers transaction results from the Application to CometBFT. When
CometBFT receives a `ResponseFinalizeBlock` containing an `ExecTxResult` with a non-zero `Code`,
the response code is logged. Past `Code` values can be queried by clients. As the transaction was
part of a decided block, the `Code` does not influence consensus. 
-->

<h3 id="query"><code class="language-plaintext highlighter-rouge">Query</code></h3>

<p>When CometBFT receives a <code class="language-plaintext highlighter-rouge">ResponseQuery</code> with a non-zero <code class="language-plaintext highlighter-rouge">Code</code>, this code is
returned directly to the client that initiated the query.</p>
:ET